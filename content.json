{"pages":[{"title":"about","text":"网页由来某个周五心血来潮，看到微信公众号推送的博客网站搭建文章，直接挂载到github pages上，连服务器的钱都不用花，看着心动，遂跟着简单搭建了起来。 搭建工具基于比较流行的网页框架hexo进行搭建，项目部署在github pages。 Why HEXO? 实话说，主要原因是刚好看到的是采用hexo搭建的教程 在几大框架中属于用户量较多的一个，各种相关问题讨论会比较多，简而言之：社区资源好 基于node.js，速度好（据说，反正我也不懂） 关于我正在武汉读研的迷惘青年少年，目前处于导师放养状态，没事各种折腾一下，不定期更新博客（一个想法…） 目前兴趣方向是Python、Java、机器学习…","link":"/about/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/09/27/hello-world/"},{"title":"IO及异常处理","text":"Java异常处理机制及IO处理机制 异常处理重要性：提高程序或软件的健壮性，即即便出现非预期的情景，程序也可以正确的处理 何为异常：一种现象，表示阻止正常进行程序执行的错误或者情况，如果没有被处理，程序就会非正常终止 异常处理的根本优势：将检测错误从处理错误中分离出来 Java中，异常为从异常类中创建的对象 关于异常的类型异常的根类为java.lang.Throwable 异常的分类： 系统错误。由Java虚拟机抛出，用Error类表示，描述的是内部系统错误 异常。用Exception类表示，描述的是由程序和外部环境所引起的错误，这些错误能被程序捕获和处理 运行时异常。用RuntimeException类表示，描述的是程序的设计错误 其中，RuntimeException、Error及其子类称为免检异常（unchecked exception），剩余的其它异常称为必检异常（checked exception），必检异常指编译器会强制程序员检查并通过try-catch块将其处理，或者在方法头进行声明。 异常处理模型123456789101112131415//基于三种操作：声明一个异常、抛出一个异常和捕获一个异常method1(){ try { //异常捕获 invoke method2; } catch (Exception ex){ Process exception; }}method2() throws Exception {//声明异常 if (an error occurs) { throw new Exception(); //抛出异常 }} 异常处理中，可以利用Scanner的方法nextLine()用来丢弃输入行中剩余的输入元素 声明异常方法抛出的必检异常必须在方法头中显式声明，告知调用者可能有出现异常 123public void myMethod() throws IOExceptionpublic void myMethod() throws Exception1, Exception2, ..., ExceptionN 注：如果方法没有在父类中声明异常，就不能在子类中对其进行继承来声明异常 抛出异常123IllegalArgumentException ex = new IllegalArgumentException(\"Wrong Argument\");throw ex; //也可使用匿名类 注：声明异常使用throws，而抛出异常使用throw 注：通常Java API中的每个异常类至少有两个构造方法：一个无参数构造方法、有个带异常描述参数的构造方法，该参数称为异常消息，可以用getMessage()进行获取 捕获异常注：异常捕获中，异常的顺序很重要，子类异常必须放在父类异常之前 JDK7之后，异常捕获可以有多捕获特性： 123catch (Exception1 | Exception2 | ... | Exceptionk ex) { code blocks;} 注：可以利用printStackTrace()方法在控制台上打印出异常的栈跟踪信息 finally字句在try-catch结构中，可加上finally字句，无论 是否产生异常 出现异常是否被捕获 finally字句总是会被执行，当使用finally字句时，可省略掉catch子句 关于何时采用异常处理语句要点：在必须处理不可预料的错误状况时采用 对于简单的、可预料的情况，可以用if-else语句进行处理 IO处理文件对象类java.io.File，该类的对象具有诸多方法，封装了文件或路径的属性，但既不包括创建文件的方法，也不包括从/向文件读/写数据（称为数据输入输出，简称I/O） 对文件进行读写操作写文件： java.io.PrintWriter类 为避免忘记关闭文件，可使用try-with-resources结构进行文件读取（由于在try块中声明和创建资源，块结束后，资源的close()方法会自动调用以关闭资源） 读文件： java.util.Scanner类 1Scanner input = new Scanner(new File(filename));","link":"/2019/09/27/Java/IO及异常处理/"},{"title":"Java基本介绍","text":"基础介绍 基础知识几个缩写 JLS , Java Language Specification, Java语言规范 API, Application Program Interface, 应用程序接口 JDK, Java Development Kit, Java开发工具包 IDE, Integrated Development Environment, 集成开发环境 基本特性描述 simple object oriented distributed interpreted robust secure architecture neutral portable high performance multithreaded dynamic 基础规范 每个Java程序至少需要一个类，类名都是以大写字母开头 程序执行都是从main方法开始，一个类可包含多个方法，但只能有一个main且main为程序开始执行的入口 Java源代码中最多有一个public类 保留字：略 注释：有两种，//是单行注释，*/ * /是多行注释，/** */是文档注释，可以使用javadoc进行注释提取，形成文档 代码块由花括号包围，每行指令结束后需要以分号结尾 Java程序区分大小写 Java源程序为.java文件，编译后的文件为.class文件，文件的编译由Java虚拟机（JVM）进行执行 字符 描述 {} 表示一个代码块 () 和方法一起使用 [] 表示数组 // 引导单行注释 “ “ 包含一个字符串 ; 标示一个语句的结束 注意：在执行一个 Java 程序时 , JVM 首先会用一个称为类加载器 ( class loader ) 的程序将类的字节码加栽到内存中 。 如果你的程序中使用其他类 ,类加栽程序会在需要它们之前动态地加栽它们 。 当加栽该类后 , JVM 使用一个称为字节码验证器 ( bytecode verifier ) 的程序来检验字节码的合法性,确保字节码不会违反 Java 的安全规范 。 Java 强制执行严格的安全规范 , 以确保来自网络的 Java 程序不会篡改和危害你的计算机 。 良好的代码风格 缩进，以表示层次，使得代码清晰、易读 空白，二元运算符两边需各加一个空格 程序错误分类 语法错误 运行错误 逻辑错误 命令行执行 java 用于运行Java文件 javac 用于编译Java文件","link":"/2019/09/27/Java/Java基本介绍/"},{"title":"基本数据结构","text":"数组等结构 一维数组用于存储相同数据类型的量，一旦创建，不可更改大小，数组名为引用变量 123456789//声明elementType[] arrayRefVar;//创建elementType[] arrayRefVar = new elementType[arraySize];//初始化elementType[] arrayRefVar = {value0, value1,...,valuek};//匿名数组创建new elementType[]{value0, value1,...,valuek}; 大小如何确定？1.指定大小(创建) 2.默认大小(初始化) 如何复制数组元素（非引用）？ 逐个操作 静态方法 System.arraycopy() clone() 12//arraycopy的使用System.arraycopy(sourceArray, srcPos, targetArray, tarPos, length); 方法中可变参数列表12//typeName... parameterName//一个方法中只能指定一个可变参数，必须放在常规参数之后 java.util.Arrays类该类提供了诸多数组处理的静态方法，如下列几条 sort(numbers) parallelSort(chars, startpos, endpos) binarySearch(arary, pos) equals(array1, array2) fill(array, num); fill(array, startpos, endpos, num) 整体填充数组；部分填充数组 toString(array) 返回包含数组内所有元素的字符串 多维数组创建、初始化同一维数组，只在于括号数量的区别，创建多维数组时，必须指定第一维的大小 锯齿数组锯齿数组指一类多维（以二维为例），其各维的数据长度不同 由于每行本身是一个数组，如果创建时，每行单独创建就可以设置不同的长度","link":"/2019/09/27/Java/基本数据结构/"},{"title":"基本语法结构","text":"分支、条件、循环 分支结构123456789if (true or false){ code block one;}else if (true or false){ code block two;}else { code block three;} 1234567switch (status){ case 0: code one; break; case 1: code two; break; default: code three;} 条件表达式12/* boolean-expression ? expression1 : expression2; */y = (x &gt; 0) ? 1 : -1; 循环结构主要有如下三种循环结构 1234//while型while (true or false){ code block;} 1234//do-while型do { code block;} while (true of false) 1234//for循环型for (i = initialValue; i &lt; endValue; i++){ code block;} 第一和第三种为前测循环，第二种为后测循环 另外还有foreach循环 123for (double e: myList){ System.out.println(e);} 如何创建方法12345/* 修饰符 返回值类型 方法名（参数列表）{ 方法体 }*/ main方法和其它方法的区别：main方法由Java虚拟机进行调用 参数传递为值传递，方法的执行并不会改变原有参数的值 如何进行变量传递？ 调用重载方法时，避免歧义调用（可与多个方法进行匹配，可能会产生编译错误） 注： 程序模块化和可重用性是软件工程的中心目标之一 。 Java 提供了很多有助于完成这一目标的有效结构 。 方法就是一个这样的结构 。 方法签名：方法名和参数列表一起构成方法签名（method signature）","link":"/2019/09/27/Java/基本语法结构/"},{"title":"9月月记","text":"第一月小结 开学9月3号，匆匆忙忙地叫了个货拉拉，把暑假放在航哥那的行李加上自己都给运到了学校，说来也是很无语，第一次坐车过来，不知道哪个门让进，结果就是：走了三个地方的门，都不让进，最后在某门卫的指引下，绕了一圈终于从东大门进了（以前都不知道还有这个门）。连续几天忙碌后，总算是安定了下来。中途有几个印象深刻的活动：开学典礼、班级班会，开学典礼第一次见到了李元元校长，隔得比较远，其实看得也不太清楚，朦朦胧胧的一个印象，讲话内容也没太多值得回忆的，也可能是午饭吃多了，导致丢失了部分记忆。开学典礼上至今还有一些印象的要数来自材料学院的导师代表讲话，不愧是导师代表，讲话和蔼中带着鼓励，讲话的内容也说不上来了，只记得一句：“每代人有每代人的长征”，给我留下的印象也亦如此。后来还有两句话让我颇有受益，一句是廖老师说的，做事之前多考虑各种大大小小的情况，做起事来的时候才能比较轻松一点；另外就是班级班会，说起班会，真是开了老半天，都是由于书记和辅导员在场，提了各种自我介绍的要求，介绍完之后顺带着选了班长和团支书，期间书记说了一句话：不要有脆弱的自尊心，用在我身上极为适合。 宿舍环境研究生新生活，从室友到宿舍配置，都比较不错，真是舒服了。终于，宿舍有了完整的洗漱台，而且装修得挺好，最令我满意还是热水了，正式结束了四年的澡堂生涯，作为一个磨磨唧唧的人，宿舍热水配置真是刚需。 上课由于2.5年学制的安排，选课要求是40个学分，而且，还要补修两门计算机课程，应该是很充实的研一的，顺便沉浸在对实验室的向往中，比较也从没真正加入过实验室，感觉实验室生活还挺新奇。 月底总结正式选好导师之后，反倒情绪低落了一些，可能是内心还是希望能做点事吧，好不容易读个研究生，万一研一混着过去了就很伤人心了。来学校之后，原来的看书计划就慢慢开始停滞，就上半月看了三本书：只是孩子、民主的细节、杀死一只知更鸟，下半个月由于各种打算和环境因素作用下，看书进度开始龟速向前，只能安慰自己说：可能是书的题材问题？希望吧，下个月尽量看完5本书吧。学习方面，只能说都了解了一下吧，至于真真确确学到的，可能也不尽人意，一会看Python爬虫，一会看Java基础，偶尔又去学机器学习了，还是过于随意，下个月得或多或少做出点计划了在学。不过最近几天还挺有成就感，搭好了博客，学会了Git的基本操作，下个月争取把SQL给学了，在熟悉一点Android开发，不然课程作业做不了了。来学校之后，之后比较规律的运动习惯也分崩离析，过了两周之后才发现没跑过步，时至今日，这个月一起跑了3次，囚徒健身上学到的锻炼倒是还坚持了有七八次的样子。由于导师选好之后也没说什么任务或者关于实验室安排的事，这个月大部分不上课的时间都是在宿舍睡觉和coding，“码”不停蹄，却没有什么收获，倒是提前进入了996状态，还是希望到时候毕业能找个好工作吧，比啥都强。写到这差不多了，口水式记录，没办法哦，多看书吧。对了，前几天出去看电影很开心。","link":"/2019/09/30/个人/9月月记/"},{"title":"周记（国庆周）","text":"10月第一周，恰逢国庆周 待在学校的一周，事先没做什么准备，以致于国庆买不到回家的票，只能买4号的票，想到就只能回去几天而且来回也不容易就作罢了，反正回去也是躺着。 看电影的一号周一跟着捷哥建议下，和博哥一起三个人去看了趟电影，我和我的祖国，一部水准还不错的爱国片，一共七个故事，比较喜欢徐峥导演的《夺冠》和宁浩导演葛优主演的《北京你好》，相较而言最后俩个故事看得我内心毫无波动，可能还是喜欢怀旧气息浓一些的画面，葛优的表演让电影很有代入感。看完之后发现主题曲居然还是王菲献唱，之后几天断断续续听了几遍。 看剧的三号对于一个一天开始于中午的人来说，一天总是短暂的，起床、午饭、下午、晚饭、晚上、睡觉，想到生活大爆炸第五季只看了不到一半，于是一股劲头上来，不可断绝，晚饭将行时已经看完第五季外加紧跟着的一期特别采访。 这期特别采访有一个细节，关于这股剧的由来，这部剧诞生于导演一个朋友的硅谷岁月回忆，说道当时在硅谷工作的程序员同事，大多是极其聪明的人才，但在工作之外的大多领域却是完全不通世事。遂有此剧，既是为这一群人发声，也意为给大众带来生活的共鸣，谁也没想到最后火遍全球。 看小说的四天国庆前几天，倒是也没落下看书，断断续续看了十几个《羊脂球》的故事，看得也倒消遣，却始终没有感受到体内——对于阅读的一种热枕，不一多时，便想到可以靠一本金庸的小说来重燃阅读的习惯，正好当时又在豆瓣上看到《天龙八部》，一拍即合，即开始了四天的《天龙八部》生涯，意识又开始置身于瞬息万变的武林中。 总结普普通通的一周，自由，个人却不善安排，总是处于得好好想想才能有所安排的时间之中，（不太深刻地）感受到人性的枷锁，陷入青春绮丽的花园之中，却总是难以自我掌控，来回踱步而已。 想起前年国庆，就是在学校度过，而是看小说，当时看着《楚留香传奇》，小时候在家看楚留香传奇的记忆始终难以忘却，一股脑便看完了八部，愈写愈飘逸，后几部寥寥数笔便落幕，当时实在难以相信，但也意味深长。 国庆七天匆匆过去，匆匆到还没看完《天空八部》，近几天怕还是得花点时间了。就这样吧，周记写到这为止，此刻已经是10月8号，正坐在图书馆4楼，4096号，正好还是2的12次方。这是第一篇周记，希望周记、月记能尽量长久的坚持写下去，提升一下文笔，提升与自我交流的能力。","link":"/2019/10/08/个人/周记（国庆周）/"},{"title":"泛型","text":"Q1：什么是泛型？泛型有什么特点、特性？ Q2：泛型为编程带来了什么优势？ Q3：泛型应该如何设计？ Q4：泛型应用举例？ A1： 泛型是Java中的一种类型，在JDK1.5中引入 A2： 泛型可以使我们定义带泛型类型的类或方法，编译时编译器会用具体的类型来替换它。 使得能够在编译时而不是运行时检测出错误。（解释：即在编写程序时，必须指定泛型类型的具体类型，如果在泛型类型处使用不相符的对象，编译器会检测出错误，提示更改） Java允许定义泛型类、泛型接口和泛型方法。 替换泛型类型的过程称为泛型实例化 泛型类型必须是引用类型","link":"/2019/09/27/Java/泛型/"},{"title":"简单程序设计","text":"基操 基本语法包的导入123//import有两种导入import java.util.Scanner; //明确导入import java.util.*; //通配符导入 同一个module下的Java文件无需引用即可使用 输入输出123456789//输入Scanner input = new Scanner(System.in); //Scanner类在包java.util.Scanner中input.nextDouble(); //.nextDouble()用来读取一个double值//输出System.out.println(\"\") ;System.out.printf(\"%4.2f\", m); //格式化输出/*%d 布尔值； %c 字符； %d 十进制整数； %f 浮点数； %e 标准科学计数法形式的数； %s 字符串；*/ Scanner对象的方法 方法 描述 nextByte() 读取一个byte类的整数 nextShort() nextInt() nextLong() nextFloat() 读取一个float类的浮点数 nextDouble() next() 读取一个字符串 nextLine() 读取整行字符串 注意：为了避免错误，不要在 nextByte(), nextShort(), nextInt(), nextLong(), nextFloat(), nextDouble(), next() 之后使用 nextLine()。 输入输出重定向 123java SentinelValue &lt; input.txtjava Classname &gt; output.txtjava SentinelValue &lt;input.txt&gt; output.txt 标识符命名 只能用三类符号: 字母、数字、$ 命名不能以数字开头 常量采用字母全大写形式，在数据类型前需加上 finall 基本数据类型共有8种数据类型（数值、字符值、布尔值数据） 类型 范围 存储大小 byte $-2^7(-128)$ ~ $2^7-127$ 8位带符号整型 short $-2^{15}(-32768)$ ~ $2^{15}-32767$ 16位带符号整型 int $-2^{31}(-2147583648)$ ~ $2^{31}-2147483647$ 32位带符号整型 long $-2^{63}$ ~ $2^{63}-1$ 64位带符号整型 float 负数范围：$-3.402823510^{38}$ ~ $-1.410^{-45}$ 正数范围：$1.410^{-45}$ ~ $3.402823510^{38}$ 32位双精度浮点数 double 负数范围：$-1.797693134862315710^{308}$ ~ $-4.910^{-324}$ 正数范围：$4.9*10^{-324}$ ~ $1.7976931348623157^{308}$ 64位双精度浮点数 此外还有字符类型 char 和逻辑类型 boolean 自动数据类型转换从左到右 byte - char - short - int - long - float - double 引用数据类型 类（class） 接口（interface） 数组（array） 基本数值操作符 运算符 操作 + 加 - 减 * 乘 / 除 % 取余 Math.pow(x, y) 幂运算 逻辑运算 操作符 操作 ！ 逻辑非 &amp;&amp; 逻辑与 || 逻辑或 ^ 逻辑异或 操作符运算优先级 操作符 优先级依次降低 var++, var– 最高级 +, -, ++var, –var (type) ! *, /, % +, - &lt;, &lt;=, &gt;, &gt;= ==, != ^ &amp;&amp; || =, +=, -=, *=, /=, %= 最低级 转义符 转义符 含义 \\b 回退一格 \\t Tab \\n 换行 \\f 换页 \\r 回车 \\\\ 反斜杠 \\&quot; 双引号 character类判断字符类型 方法 功能 isDigit(ch) 判断字符是否为数字，是则返回true，否则返回false isLetter(ch) 是否是字母 isLetterOrDigit(ch) 是否为字母或数字 isLowerCase(ch) 是否是小写字母 isUpperCase(ch) 是否是大写字母 toLowerCase(ch) 返回字符的小写形式 toUpperCase(ch) 返回字符的大写形式 字符串Java中字符串为String类型，String类有如下方法： 方法 描述 length() 返回字符数 charAt(index) 返回指定位置的字符 concat(s1) 将本字符串与字符串s1进行连接，返回新字符 toUpperCase() 将字符串转换成全大写字符的字符串并返回 toLowerCase() 将字符串转换成全小写字符的字符串并返回 trim() 去掉字符串两边的空白字符并返回 equals(s1) 是否等于字符串s1，是则返回true equalsIgnoreCase(s1) 不区分大小写，判断是否等于s1 compareTo(s1) 比较大小，大于、等于或小于，分别返回大于0、等于0、小于0的整数 compareToIgnoreCase(s1) 不区分大小写，同上 startsWith(prefix) 是否以prefix作为前缀开始 endsWith(suffix) 是否以suffix作为后缀结束 contains(s1) s1是否是字符串的子串 substring(beginIndex) 返回 从位置beginIndex到字符串末尾 的字符串 substring(beginIndex, endIndex) 返回从beginIndex到endIndex（不包含endIndex处的字符）的字符串 补充： 将数值型字符串转换成数值 Interger.parseInt(intString) 转换成整数 Double.parseDouble(doubleString) 转换成双精度浮点数 数值可与字符串进行连接构成字符串 String s = number + &quot;&quot;; 获取时间显示当前时间可通过调用 System.currentTimeMillis()， 该方法返回的是从UNIX时间戳（1970年1月1日00:00:00）到当前时刻的毫秒数 软件开发过程 需求规范 需求分析 系统设计 实现 测试 部署 维护","link":"/2019/09/27/Java/简单程序设计/"},{"title":"BeautifulSoup库笔记","text":"网页信息解析库 使用方式： 12from bs4 import BeautifulSoupsoup = BeautifulSoup('&lt;html&gt;data&lt;/html&gt;', 'html.parser') 只要提供的是标签数据，beautifulsoup库都能做很好的解析，可以讲数据处理成树状结构数据 基本标签和解释器共有四类解释器：html.parser、lxml、xml、html5lib （其中lxml也是处理HTML的解释器，xml也可以写作lxml-xml）共有五种基本元素： Tag(标签)，指整个标签 Name(标签的名字) ttributes(标签的属性)，为字典类型，存储了标签的各属性值，如class、href、id等。1. 通过.attrs可获取标签所有的属性 2. 通过类似字典的操作访问，如tag[‘class’] NavigableString(标签内的非属性字符串)，字符串，为标签内的字符串信息，通过.string获取，若标签只有一个子节点，也可以通过.string直接获取子节点的字符串内容 Comment(标签内字符串的注释部分)，不常用，注释是利用!–符号构成的内容&lt;!--This is a comment--&gt;，如，通过NavigableString类可以直接显示其文本内容，不会注明为注释，需要利用一些手段进行自行判断，comment也是一种NaviableString 遍历操作由于BeautifulSoup对象为树结构，可进行上行、下行和平行遍历 下行遍历 .contents 获得子节点列表，将所有子节点存入列表，可通过列表结构进行选择性地访问 .children 获得子节点的迭代类型，与.contents类似，用于循环遍历子节点 .descendants 获得子孙节点的迭代类型，包含所有的子孙节点，用于循环遍历 上行遍历 .parent 获得节点的父节点标签，其中根节点的父节点为自身 .parents 可获得节点的所有先辈标签的迭代类型 平行遍历 .next_sibling 返回按照HTML文本顺序的下一个平行节点标签 .previous_sibling 返回按照HTML文本顺序的上一个平行节点标签 .next_siblings 迭代类型,返回按照HTML文本顺序的后续所有平行节点标签 .previous_siblings 迭代类型,返回按照HTML文本顺序的前续所有平行节点标签 注意 导入时需要注意，from bs4 import BeautifulSoup，而不是直接导入BeautifulSoup 利用beautifulsoup处理网页内容时，除了网页内容，还需要给出一个解释器，如html.parser或者lxml 利用BeautifulSoup.prettify()可将处理过得网页内容（beautifulsoup对象或者标签）有层次（增加换行符）得再现出来，prettify()方法只能作用于BeautifulSoup对象 bs4库默认将所有HTML输入都变成utf-8编码，而由于Python 3以上的版本默认支持编码为utf-8所有解析无障碍，但如果是Python 2的版本，则会出现编码上的问题 信息标记的若干形式 XML(eXtensible Markup Language） –最早的通用信息标记语言，可拓展性好，但略繁琐。适合Internet上的信息交互与传递 内容： … &lt;\\name&gt; 注释： JSON(JavaScipt Object Notation) –信息有类型，适合程序处理(js)，较XML简洁，但无法表示注释。适合移动应用云端和节点的信息通信 从名字可以看出是面向对象的一种表达方式，内容采用类型的键值对key: value进行表示 并列内容采用, 进行分隔 注意：字符串都是用双引号表示，单引号不可以，当值的信息有多个时，才有[ , ]的形式进行组织，可以嵌套，如果嵌套的对象为键值对，则需要用{}符号 YAML(YAML Ain’t Markup Language) –信息无类型，文本信息比例最高，且有注释，可读性高。适合各类系统的配置文件 采用无类型的键值对进行信息存储，通过缩进格式来表示信息的嵌套（层次关系） 采用-号表示并列关系 采用#进行注释 采用|进行整块数据的表达 信息提取的方法 形式解析（需要标记解释器） 无视搜索（需要文本查找函数 ） 融合搜索（需要标记解析器和文本查找函数） 文本查找函数（过滤器）： &lt;&gt;.find() &lt;&gt;.find_all(name, attrs, recursive, string, **kwargs) 返回一个列表类型，存储查找的结果 name:对标签名称的检索字符串 attrs:对标签属性值的检索字符串，可标注属性检索 recursive:是否对子孙全部检索，默认为True string:&lt;&gt;…&lt;/&gt;中字符串区域的检索字符串 如果传入参数为列表，Beautiful Soup会将与列表中任一元素匹配的内容返回 参数也可以为方法 可以通过 find_all() 方法的 attrs 参数定义一个字典参数来搜索包含特殊属性的tag 注意：(…) 等价于 .find_all(…); soup(…)等价于 soup.find_all(…) 拓展方法： &lt;&gt;.find() 搜索且只返回一个结果,同.find_all()参数 &lt;&gt;.find_parents() 在先辈节点中搜索,返回列表类型,同.find_all()参数 &lt;&gt;.find_parent() 在先辈节点中返回一个结果,同.find()参数 &lt;&gt;.find_next_siblings() 在后续平行节点中搜索,返回列表类型,同.find_all()参数 &lt;&gt;.find_next_sibling() 在后续平行节点中返回一个结果,同.find()参数 &lt;&gt;.find_previous_siblings() 在前序平行节点中搜索,返回列表类型,同.find_all()参数 &lt;&gt;.find_previous_sibling() 在前序平行节点中返回一个结果,同.find()参数","link":"/2019/09/27/网络爬虫/BeautifulSoup库笔记/"},{"title":"requests库笔记","text":"对于库的选择和Robots协议作基本介绍，requests库见官方中文文档 网络爬虫规模及爬虫库的选择 小规模。当数据量小，且对爬取速度不敏感时采用Requests库 中规模。当数据规模较大，且对爬去速度敏感时采用Scrapy库 大规模。 全网爬取(搜索引擎)，且爬取速度特别关键时需定制开发 如何对网络爬虫进行限制 来源审查：判断User-Agent并进行限制，检查HTTP协议头部的User-Agent，通过一定的设定后策略，只相应允许的User-Agent进行访问 发布公告：通过Robots（Robots Exclusion Standard）协议，将网站的爬取策略（一个txt文件）告诉所有爬虫，要求按照规则对网页进行爬取 （网络爬虫也可以不遵守Robots协议，但是存在着法律风险） 1234567891011121314# Robots demo from www.jd.com/robot.txt# 网络爬虫应该能自动识别robots.txt，并根据内容进行爬取User-agent: * Disallow: /?* Disallow: /pop/*.html Disallow: /pinpai/*.html?* User-agent: EtaoSpider Disallow: / User-agent: HuihuiSpider Disallow: / User-agent: GwdangSpider Disallow: / User-agent: WochachaSpider Disallow: /","link":"/2019/09/27/网络爬虫/requests库笔记/"},{"title":"第一篇博客","text":"喜提博客 经常下午和晚上的摸索，终于搭建起自己的博客，或者说是个人网站，来之不易，希望好好坚持下去！","link":"/2019/09/27/个人/第一篇博客/"},{"title":"正则表达式","text":"简单介绍正则表达式的思想及用法 什么是正则表达式 用来简洁表达一组字符串的表达式 一种通用的字符串表达框架 可以用来判断某字符串的特征归属 更是一种针对字符串表达“简洁”和“特征”思想的工具 独特优势简洁高效，用来简洁表达一组字符串，主要使用在字符串匹配中（一行胜千言） 语法构成由字符和操作符构成 操作符 说明 实例 . 表示任何单个字符(除了\\) [ ] 字符集,对单个字符给出取值范围 [abc]表示a、b、c,[a‐z]表示a到z单个字符 [^ ] 非字符集,对单个字符给出排除范围 [^abc]表示非a或b或c的单个字符 * 前一个字符0次或无限次扩展 abc* 表示 ab、abc、abcc、abccc等 + 前一个字符1次或无限次扩展 abc+ 表示 abc、abcc、abccc等 ? 前一个字符0次或1次扩展 abc? 表示 ab、abc | 左右表达式任意一个 abc {m} 扩展前一个字符m次 ab{2}c表示abbc {m,n} 扩展前一个字符m至n次(含n) ab{1,2}c表示abc、abbc ^ 匹配字符串开头 ^abc表示abc且在一个字符串的开头 $ 匹配字符串结尾 abc$表示abc且在一个字符串的结尾 ( ) 分组标记,内部只能使用|操作符 (abc)表示abc, （abc|def）表示abc、def \\d 数字,等价于[0‐9] \\w 单词字符,等价于[A‐Za‐z0‐9] 补充： 匹配中文字符 1[\\u4e00-\\u9fa5] 匹配IP地址(4段，每段为0-255) 1((25[0-5]|2\\d{0-4}\\d|1\\d{2}|[1-9]?\\d).){3}(25[0-5]|2\\d{0-4}\\d|1\\d{2}|[1-9]?\\d) 使用正则表达式编译（将符合正则表达式语法的字符串转换成正则表达式特征） python中使用1import re re库需要采用raw string类型(字符串中的\\不被理解为转移符，如果用string就会比较繁琐)表示正则表达式，表示为r'text' 通过group方法，可以获取正则表达式中的字符串 12345re.search(r'text').group()re.search(r'text').group(0) # 与上行相同，反正整体匹配字符串re.search(r'text').group(1) # re.search(r'text').group(2)re.search(r'text').group(3) 匹配规则贪婪匹配：匹配字符串为满足条件的最长字符串 通过在匹配规则中加上?可以进行最小匹配","link":"/2019/09/27/网络爬虫/正则表达式/"},{"title":"类和对象","text":"面向过程范式重在设计方法。面向对象范式重在对象和对象的操作，结合了面向过程范式的功能以及将数据和操作集成在对象中的特点。 重点：面向对象思维 面向对象程序设计的三大支柱：封装、继承、多态 能有助于高效开发GUI和大型软件系统 类和对象的若干细节类是一个模板、蓝本或是合约，用来定义对象的数据域及方法 一个对象是类的实例，创建实例的过程称为实例化 Java类通过使用变量来定义数据域，使用方法来定义动作 构造方法Java类提供了构造方法，可调用它构造一个新的对象，主要是为了完成一些初始化工作，作用是初始化对象。构造方法名与类名相同，参考Python的__init__()及其参数设定 特性： 必须具备与类相同的名字 没有返回值类型，也没有void，举例： public Circle(){ } //没有返回值类型，方法头只有修饰符、方法名和参数列表 是在创新对象时通过new进行调用的 当不定义构造方法时，会隐式定义一个方法体为空的无参构造方法，也称为默认构造方法 匿名对象类似与前面提到过的匿名数组，只是省去了定义过程，直接进行了对象创建，使用时可同时调用其方法，省去不必要的步骤。如： new Circle(5).getArea() 静态变量、常量、方法要点：静态变量（也称类变量）可被类中所有对象共享，静态方法（也称类方法）不能访问类中的实例成员。且无需创建对象就可调用静态变量和静态方法。 诚然，实例对象也可以访问静态变量和方法 UML中静态变量、常量、方法以下划线标注，定义时以修饰符 static 修饰定义即可，常量则再加上 final ，比如： final static double PI = 3.1415 可见性修饰符补充：package (default) public private protected 修饰符及可见性描述： 修饰符 可见性 (default) 可被同一个包中的任一类访问，仅限同一包之中（也称包私有或包内访问） public 能被任意其它类访问 private 限定只能在自身的类中访问 protected 限定只能子类访问 注： ｐrivate 只能应用在类的成员上。修饰符 public 可以应用在类或类的成员上。局部变量上使用修饰符 public、private 会导致编译错误。 数据域封装为了同时保证数据域的封装和数据安全修改，一般通过一个 get 方法进行数据的获取，通过 set 方法进行数据的修改。 其中 get 方法称为访问器（accessor）， set 方法称为称为修改器（mutator）。 1234public returnType getPropertyName(); //get的常规定义public boolean isPropertyName(); //当返回值是boolean类型时的常规定义public void setPropertyName(dataType propertyValue); //set的常规定义 不可变对象不可变对象需要满足以下三条要求 所有数据域（属性）都是私有的 没有 set 方法 没有一个 get 方法方法会返回只想可变数据域的引用 this引用在引用隐藏数据域以及调用一个重载的构造方法时，this引用是必须的 this是指向调用对象本身的引用名，可通过调用 this引用对象的实例成员 注：Java要求 this 放在其它可执行语句之前 类中的关系 关联。 描述两个类之间的活动，uml中采用实线表示 聚合。描述两个对象的归属关系，所有者对象称为聚集对象，其类称为聚集类，从属的则是被聚集对象，被聚集类。（一个对象可被多的聚集对象拥有）。uml中用空心菱形表示 组合。一个对象只归属一个聚集对象，那它和聚集对象间就是组合关系。uml中用实心菱形表示 继承。通过一个定义的通用类（父类、超类、基类），扩充该类为一个更加特定的类（子类、扩展类、派生类）的操作。 继承与组合：继承是 “is-a” 的关系建模，而组合是 “has-a” 的关系建模 基本数据类型与数据包装类Q：为什么要将基本数据类型作为对象处理？ A：Java中某些方法的参数必须是对象 Q：为什么通常情况下基本数据类型不作为对象来处理？ A：处理对象需要额外的系统开销，会降低语言的性能 基本数据类型对象类（也称数据包装类）： Integer Byte Short Float Double Character Boolean 这些对象类所属包：java.lang 装箱（boxing）：将基本类型值转换成包装对象的过程 开箱（unboxing）：将包装对象转换成基本数据值的过程 继承与多态继承语法如下： 12//此处例子为Circle类继承GeometricObject类public class Circle extends GeometricObject 不同于this 对调用对象的引用，super指的是这个关键字所在类的类（与this相同，super也应该写在构造方法的第一条语句处），使用途径： 调用父类的构造方法（子类能继承父类的属性、普通方法，不能继承其构造方法） 调用父类的方法（一般用于方法的重写） 如果子类的构造方法中没有显式调用父类构造方法，编译器就会自动地将super()作为构造方法的第一句，如下： 12345678//下列两者等价public ClassName(){ statements;}public ClassName(){ super(); statements;} 注：静态方法无法被覆盖，如果父类中定义的静态方法在子类中被重新定义，那么在父类中定义的静态方法将被隐藏，可通过SuperClassName.staticMethodName调用隐藏的静态方法。 方法重写与方法重载 方法重写指两方法具有相同的签名（方法名和参数列表）和返回值，发生在继承关系的不同类中 方法重写指两方法具有相同的方法名，但参数列表不同，可发生在继承关系的不同类中，也可以发生在任何一个类之中 通常在方法重写前加上重写标注：@override，以表明接下来的方法为重写方法，要注意的是加上该标注后，后面的方法必须要重写父类的一个方法，如果没有重写方法，则会出现编译错误。 toString方法与equals方法由于所有没有显式继承关系的Java类都继承于java.lang.Object，而该类中有方法toString()，所有所有类都会继承该方法，默认下System.out.print(object)等价于System.out.print(object.toString())，如果要返回特定的信息，就需要改写该方法。 此外，java.lang.object中还有一个方便、常用的方法：equals()，用于测试两个对象是否相等 而==用来比较值是否相等 注：重写equals方式时，应该这样：equals(Object obj)，而不是equals(SomeClassName obj) 多态多态指父类的变量可以指向子类对象 一些解释：每个子类实例既是自身的实例，也是其父类的实例，而其父类的实例不能是子类的实例。即使用父类对象的地方都可以使用子类对象。 动态绑定描述：方法在沿着继承链的多个类中实现，JVM在运行时决定调用那个方法 具体调用哪个方法取决于 对象的实际类型，而非声明类型 如果实际类型中实现该方法，则沿着继承链依次向前，找到的第一个就是JVM将调用的方法 类型转换要点：隐式转换(implicit casting)显式转换(explicit casting) Q：为什么需要类型转换？ A：因为虽然声明类型不等于实际类型，但是声明类型决定了JVM在编译时具体匹配的方法 一个子类的实例总可以转换成一个父类的实例，该操作称为向上转换（upcasting），为确保转换的正确性，可在转换前加上一个判断操作：isinstanceof（注：isinstance并不是一个方法，而是一个运算符，用于两个对象，使用举例如下代码块） 1Circle isinstanceof GeometricObject; //其结果为boolean型 注：由于.操作符优先级高于类型转换，所有需要将类型转换与对象名用括号括起来，使之先于.操作 注：对于对象引用和基本类型值而言，类型转换的操作有所不同，对基本类型值进行类型转换会返回一个新的值，而对对象引用进行类型转换并不会创建新的对象，而是指向同一个对象。 关于声明类型与动态绑定的一个说明对了一个继承关系：Parent类和Child类， 声明Parent p = new Child()，那么p的声明类型为Parent，实际类型为Child，由于声明类型的缘故，p不能调用出现在Child而不出现在Parent的方法；而对于两者都有的方法（同一签名的方法），由于动态绑定的缘故，p会调用Child类中的该方法。 如何防止拓展和重写要点：利用final修饰 被final修饰的类和方法是无法被拓展的。被final修饰的类称为最终类，无法被继承，常见的最终类有：Math String StringBuilder StringBuffer等。被final修饰的方法称为最终方法。 常用类BigInteger和BigDecimal类作用：表示任意大小和精度的整数或者浮点数 方法： add subtract multiple divide remainder compareTo 所属包：java.math 12345678910//创建及使用BigInteger element = new BigInteger(String); //注：只接受String类参数BigDecimal element = new BigDecimal(String);//使用举例BigInteger a = new BigInterger(\"293726028508236\");BigInteger b = new BigInterger(\"3253259723\");BigInteger c = a.multiply(b);BigDecimal d = a.divide(b, 20, BigDecimal.ROUND_UP); //控制精度，此处为保留小数点后20位，舍入方式为BigDecimal.ROUND_UP的BIgDecimal对象 String类特点： 不可更改。一旦创建，其内容无法改变 限定字符串对象：为提高系统效率节约内存，对于相同字符序列的字符串，Java虚拟机使用同一个实例 123String s1 = \"hello world\";String s2 = \"hello world\";System.out.print(s1 == s2); //输出为true,即两个\"hello world\"在系统中为同一个字符串对象，也称限定字符串对象 字符串与数组间的转换： 1234char[] chars = &quot;Java&quot;.toCharArray();String str = new String(new char[]{&apos;J&apos;,&apos;a&apos;,&apos;v&apos;,&apos;a&apos;});String str = String.valueOf(new char[]{&apos;J&apos;,&apos;a&apos;,&apos;v&apos;,&apos;a&apos;}) 将字符和数值转换成字符串： 利用连接符号 + 利用 String 类的静态方法 valueOf 字符串的格式化： 123456String.format(format, item1, item2, ..., itemk);//举例如下String s = String.format(\"%7.2f%6d%-4s\", 45.446, 12, \"AB\");//注：以下两种形式等价：System.out.printf(format, item1, item2, ..., itemk);System.out.print(String.format(format, item1, item2, ..., itemk)); StringBuilder和StringBuffer类要点：此两类类似与String类，区别在于此两类是可变的； 一般而言，任何需要使用字符串的地方，都可以使用这两类，且比String类更加灵活。 两者的使用区别：多任务并发访问情况下，采用StringBuffer，而如果是单任务访问，StringBuilder则更有效果（StringBuffer中修改缓冲区的方法是同步的）。 所有能使用StringBuilder的地方都可以使用StringBuffer。 ArrayList类要点：一种泛型类，可用来存储对象的数组，数组大小可变 泛型类解释：以ArrayList为例，ArrayList为泛型类，具有泛型类型E，创建时，可执行一个具体的类型来代替E 123456//创建ArrayList&lt;java.util.Data&gt; dates = new ArrayList&lt;java.util.Date&gt;();ArrayList&lt;String&gt; cities = new ArrayList&lt;String&gt;();//JDK1.7开始，下列两者等效，此特性称为推导类型ArrayList&lt;AConcreteType&gt; list = new ArrayList&lt;AconcreteType&gt;();ArrayList&lt;AConcreteType&gt; list = new ArrayList(); 比较有用的几个方法： Arrays.aslist()：传入一个数组对象，会返回一个列表，该列表可以传递给ArrayList用于构造ArrayList ArraysList.toArray()：用上面一个作用相反，将ArrayList变为数组对象 java.util.Collections.sort()：用于可元素可比较的列表，可将其对元素进行排序 java.util.Collections.max()：返回列表最大元素 java.util.Collections.min()：返回列表最小元素 java.util.Collections.shuffle()：可随机打乱列表的元素 注：可以通过Object.getClass()放回对象的对象类型信息 其它常用Java类Data类 Random类 Point2D类 Integer与Double类 抽象类和接口抽象类要点：有时候，当一个父类设计得过于抽象，以至于没有任何具体实例时，这种类称为抽象类。 抽象类无法用于创建对象实例；可包括抽象方法，这种方法的具体步骤将在子类中实现 在UML中，抽象类名用斜体字体表示 抽象类的签名中，需要加上abstract关键字 抽象类的构造方法应该是protected的，以确保只能被其继承子类所调用 继承抽象类的子类如果不是抽象类，则必须具体实现抽象父类中的所有抽象方法，如果无法实现抽象父类的所有抽象方法，那么子类就应该是一个抽象类 父类是非抽象类，子类也可以定义为抽象类 满足以下任意条件的类就是抽象类： 显式地包含了一个抽象方法的声明 父类声明的抽象方法为在该类和其父类中实现 父接口中声明或继承一个方法，且类中未声明或继承一个方法来实现它 类中有一个未实现的方法（**自定义或继承） 抽象方法的好处： 抽象类中写抽象方法后，可以以抽象类声明某个子类，然后通过动态绑定来绑定具体的实现方法 接口要点：只包含变量和抽象方法的，与类相似的结构。是公共静态常量和公共抽象实例方法的集合 可看做一种特殊的类，与抽象类相似，无法创建实例。类与接口之间的关系称为 接口继承，也简称为继承。 接口之间的继承可以是多继承，一个类可以实现（关键字implements）多个接口 接口中所有数据字段都隐含为public static final，所有方法都隐含为public abstract 12345678/*修饰符 interface 接口名{ 常量声明 方法签名}*/modifier interface InterfaceName {} 常用几个接口（都包含在包java.lang中）： Comparable Cloneable 为空接口，（空接口称为标记接口） Runnable","link":"/2019/09/27/Java/类和对象/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"个人","slug":"个人","link":"/tags/个人/"},{"name":"网络爬虫","slug":"网络爬虫","link":"/tags/网络爬虫/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"BeautifulSoup库","slug":"BeautifulSoup库","link":"/tags/BeautifulSoup库/"},{"name":"requests库","slug":"requests库","link":"/tags/requests库/"},{"name":"随笔","slug":"随笔","link":"/tags/随笔/"},{"name":"re库","slug":"re库","link":"/tags/re库/"}],"categories":[{"name":"Java-JavaSE","slug":"Java-JavaSE","link":"/categories/Java-JavaSE/"},{"name":"月记","slug":"月记","link":"/categories/月记/"},{"name":"周记","slug":"周记","link":"/categories/周记/"},{"name":"Python-网络爬虫","slug":"Python-网络爬虫","link":"/categories/Python-网络爬虫/"},{"name":"随笔","slug":"随笔","link":"/categories/随笔/"}]}