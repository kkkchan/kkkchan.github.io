{"pages":[{"title":"关于","text":"网页由来某个周五心血来潮，看到微信公众号推送的博客网站搭建文章，直接挂载到github pages上，连服务器的钱都不用花，看着心动，遂跟着简单搭建了起来。 搭建工具基于比较流行的网页框架hexo进行搭建，项目部署在github pages。 Why HEXO? 实话说，主要原因是刚好看到的是采用hexo搭建的教程 在几大框架中属于用户量较多的一个，各种相关问题讨论会比较多，简而言之：社区资源好 基于node.js，速度好（据说，反正我也不懂） 关于我正在武汉读研的迷惘青年少年，目前处于导师放养状态，没事各种折腾一下，不定期更新博客（一个想法…） 目前兴趣方向是Python、Java、机器学习…","link":"/about/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/09/27/hello-world/"},{"title":"Java基本介绍","text":"基础介绍 基础知识几个缩写 JLS , Java Language Specification, Java语言规范 API, Application Program Interface, 应用程序接口 JDK, Java Development Kit, Java开发工具包 IDE, Integrated Development Environment, 集成开发环境 基本特性描述 simple object oriented distributed interpreted robust secure architecture neutral portable high performance multithreaded dynamic 基础规范 每个Java程序至少需要一个类，类名都是以大写字母开头 程序执行都是从main方法开始，一个类可包含多个方法，但只能有一个main且main为程序开始执行的入口 Java源代码中最多有一个public类 保留字：略 注释：有两种，//是单行注释，*/ * /是多行注释，/** */是文档注释，可以使用javadoc进行注释提取，形成文档 代码块由花括号包围，每行指令结束后需要以分号结尾 Java程序区分大小写 Java源程序为.java文件，编译后的文件为.class文件，文件的编译由Java虚拟机（JVM）进行执行 字符 描述 {} 表示一个代码块 () 和方法一起使用 [] 表示数组 // 引导单行注释 “ “ 包含一个字符串 ; 标示一个语句的结束 注意：在执行一个 Java 程序时 , JVM 首先会用一个称为类加载器 ( class loader ) 的程序将类的字节码加栽到内存中 。 如果你的程序中使用其他类 ,类加栽程序会在需要它们之前动态地加栽它们 。 当加栽该类后 , JVM 使用一个称为字节码验证器 ( bytecode verifier ) 的程序来检验字节码的合法性,确保字节码不会违反 Java 的安全规范 。 Java 强制执行严格的安全规范 , 以确保来自网络的 Java 程序不会篡改和危害你的计算机 。 良好的代码风格 缩进，以表示层次，使得代码清晰、易读 空白，二元运算符两边需各加一个空格 程序错误分类 语法错误 运行错误 逻辑错误 命令行执行 java 用于运行Java文件 javac 用于编译Java文件","link":"/2019/09/27/Java/Java基本介绍/"},{"title":"IO及异常处理","text":"Java异常处理机制及IO处理机制 异常处理重要性：提高程序或软件的健壮性，即即便出现非预期的情景，程序也可以正确的处理 何为异常：一种现象，表示阻止正常进行程序执行的错误或者情况，如果没有被处理，程序就会非正常终止 异常处理的根本优势：将检测错误从处理错误中分离出来 Java中，异常为从异常类中创建的对象 关于异常的类型异常的根类为java.lang.Throwable 异常的分类： 系统错误。由Java虚拟机抛出，用Error类表示，描述的是内部系统错误 异常。用Exception类表示，描述的是由程序和外部环境所引起的错误，这些错误能被程序捕获和处理 运行时异常。用RuntimeException类表示，描述的是程序的设计错误 其中，RuntimeException、Error及其子类称为免检异常（unchecked exception），剩余的其它异常称为必检异常（checked exception），必检异常指编译器会强制程序员检查并通过try-catch块将其处理，或者在方法头进行声明。 异常处理模型123456789101112131415//基于三种操作：声明一个异常、抛出一个异常和捕获一个异常method1(){ try { //异常捕获 invoke method2; } catch (Exception ex){ Process exception; }}method2() throws Exception {//声明异常 if (an error occurs) { throw new Exception(); //抛出异常 }} 异常处理中，可以利用Scanner的方法nextLine()用来丢弃输入行中剩余的输入元素 声明异常方法抛出的必检异常必须在方法头中显式声明，告知调用者可能有出现异常 123public void myMethod() throws IOExceptionpublic void myMethod() throws Exception1, Exception2, ..., ExceptionN 注：如果方法没有在父类中声明异常，就不能在子类中对其进行继承来声明异常 抛出异常123IllegalArgumentException ex = new IllegalArgumentException(\"Wrong Argument\");throw ex; //也可使用匿名类 注：声明异常使用throws，而抛出异常使用throw 注：通常Java API中的每个异常类至少有两个构造方法：一个无参数构造方法、有个带异常描述参数的构造方法，该参数称为异常消息，可以用getMessage()进行获取 捕获异常注：异常捕获中，异常的顺序很重要，子类异常必须放在父类异常之前 JDK7之后，异常捕获可以有多捕获特性： 123catch (Exception1 | Exception2 | ... | Exceptionk ex) { code blocks;} 注：可以利用printStackTrace()方法在控制台上打印出异常的栈跟踪信息 finally字句在try-catch结构中，可加上finally字句，无论 是否产生异常 出现异常是否被捕获 finally字句总是会被执行，当使用finally字句时，可省略掉catch子句 关于何时采用异常处理语句要点：在必须处理不可预料的错误状况时采用 对于简单的、可预料的情况，可以用if-else语句进行处理 IO处理文件对象类java.io.File，该类的对象具有诸多方法，封装了文件或路径的属性，但既不包括创建文件的方法，也不包括从/向文件读/写数据（称为数据输入输出，简称I/O） 对文件进行读写操作写文件： java.io.PrintWriter类 为避免忘记关闭文件，可使用try-with-resources结构进行文件读取（由于在try块中声明和创建资源，块结束后，资源的close()方法会自动调用以关闭资源） 读文件： java.util.Scanner类 1Scanner input = new Scanner(new File(filename));","link":"/2019/09/27/Java/IO及异常处理/"},{"title":"基本数据结构","text":"数组等结构 一维数组用于存储相同数据类型的量，一旦创建，不可更改大小，数组名为引用变量 123456789//声明elementType[] arrayRefVar;//创建elementType[] arrayRefVar = new elementType[arraySize];//初始化elementType[] arrayRefVar = {value0, value1,...,valuek};//匿名数组创建new elementType[]{value0, value1,...,valuek}; 大小如何确定？1.指定大小(创建) 2.默认大小(初始化) 如何复制数组元素（非引用）？ 逐个操作 静态方法 System.arraycopy() clone() 12//arraycopy的使用System.arraycopy(sourceArray, srcPos, targetArray, tarPos, length); 方法中可变参数列表12//typeName... parameterName//一个方法中只能指定一个可变参数，必须放在常规参数之后 java.util.Arrays类该类提供了诸多数组处理的静态方法，如下列几条 sort(numbers) parallelSort(chars, startpos, endpos) binarySearch(arary, pos) equals(array1, array2) fill(array, num); fill(array, startpos, endpos, num) 整体填充数组；部分填充数组 toString(array) 返回包含数组内所有元素的字符串 多维数组创建、初始化同一维数组，只在于括号数量的区别，创建多维数组时，必须指定第一维的大小 锯齿数组锯齿数组指一类多维（以二维为例），其各维的数据长度不同 由于每行本身是一个数组，如果创建时，每行单独创建就可以设置不同的长度","link":"/2019/09/27/Java/基本数据结构/"},{"title":"基本语法结构","text":"分支、条件、循环 分支结构123456789if (true or false){ code block one;}else if (true or false){ code block two;}else { code block three;} 1234567switch (status){ case 0: code one; break; case 1: code two; break; default: code three;} 条件表达式12/* boolean-expression ? expression1 : expression2; */y = (x &gt; 0) ? 1 : -1; 循环结构主要有如下三种循环结构 1234//while型while (true or false){ code block;} 1234//do-while型do { code block;} while (true of false) 1234//for循环型for (i = initialValue; i &lt; endValue; i++){ code block;} 第一和第三种为前测循环，第二种为后测循环 另外还有foreach循环 123for (double e: myList){ System.out.println(e);} 如何创建方法12345/* 修饰符 返回值类型 方法名（参数列表）{ 方法体 }*/ main方法和其它方法的区别：main方法由Java虚拟机进行调用 参数传递为值传递，方法的执行并不会改变原有参数的值 如何进行变量传递？ 调用重载方法时，避免歧义调用（可与多个方法进行匹配，可能会产生编译错误） 注： 程序模块化和可重用性是软件工程的中心目标之一 。 Java 提供了很多有助于完成这一目标的有效结构 。 方法就是一个这样的结构 。 方法签名：方法名和参数列表一起构成方法签名（method signature）","link":"/2019/09/27/Java/基本语法结构/"},{"title":"泛型","text":"Q1：什么是泛型？泛型有什么特点、特性？ Q2：泛型为编程带来了什么优势？ Q3：泛型应该如何设计？ Q4：泛型应用举例？ A1： 泛型是Java中的一种类型，在JDK1.5中引入 A2： 泛型可以使我们定义带泛型类型的类或方法，编译时编译器会用具体的类型来替换它。 使得能够在编译时而不是运行时检测出错误。（解释：即在编写程序时，必须指定泛型类型的具体类型，如果在泛型类型处使用不相符的对象，编译器会检测出错误，提示更改） Java允许定义泛型类、泛型接口和泛型方法。 替换泛型类型的过程称为泛型实例化 泛型类型必须是引用类型","link":"/2019/09/27/Java/泛型/"},{"title":"数据结构和操作的部分库","text":"跟着《Python Cookbook》和《Python 3面向对象编程》继续学习Python。使用工具主要为VsCode和IPython。利用交互式环境IPython，可以很方便获取库的使用说明和方法、属性目录。 可迭代对象的拆分(重点：*操作)string库有比较方便的方法，要进行一些小测试时很方便（比如结合random库随机产生3位随机字母）： 12345678910111213import stringstring.ascii_letters'''abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'''string.ascii_lowercase'''abcdefghijklmnopqrstuvwxyz'''string.ascii_uppercase'''ABCDEFGHIJKLMNOPQRSTUVWXYZ'''string.digits'''0123456789'''string.hexdigits'''0123456789abcdefABCDEF'''string.octdigits'''01234567''' deque库deque为双端队列，创建时指定最大长度，插入数据时可从首插入也可从尾插入，移出数据时亦是如此。当元素已满时，继续插入，会自动将队列中按插入方向相反方向的第一个元素移出。 123456789101112from collections import dequed = deque(maxlen=5) # 创建'''在IPython中通过 dir(deque) 可看到以下方法或属性（只保留了部分方法或属性）'''append() # 右端入队appendleft() # 左端入队pop() # 右端出队popleft() # 左端出队remove() # 出队第一个与传递参数相同的元素reverse() # 逆转元素排列顺序rotate() # ‘旋转’，默认步进为1，即将真个队列向后移动一位，最后的元素移至开头extend() # 传递可迭代类型，将该可迭代类型元素逐个右端入队extendleft() # 同上，只是变成左端入队 heapq库主要方法如下： 1234567heapify() # 将数据（通常为列表数据）变为堆heappop() # 出堆（最小），和heappush的用法可参照下面PriorityQueue中的用法heappush() # 入堆nlargest() # 获取n个最大元素'''用法示范heapq.nlargest(n, list)'''nsmallest() # 获取n个最小元素'''用法示范heapq.nsmallest(n, list)''' 经验总结：找出一组元素中比较小的数 找最小或者最大的一个数。min(),max() 找最小或者最大的一些数（个数不多）。nsmallest,nlargest()(from heapq)；堆算法 找最小或者最大的一些数（个人接近总体）。sorted(items)[:N],sorted(items)[-N:]；排序后切片 PriorityQueue构造（利用heapq）123456789101112import heapqclass PriorityQueue: def __init__(self): self._queue = [] self._index = 0 def push(self, item, priority): heapq.heappush(self._queue, (-priority, self._index, item)) self._index += 1 def pop(self): return heapq.heappop(self._queue)[-1] defaultdict对于多值映射的实现，通常是将值设为集合或列表元素。具体实现则有两种： 1234567891011# 通过普通字典d = {}# d.setdefault('a', []).append(1)for key, value in pairs: if key not in d: d[key].append(value)# 通过defaultdictd = defaultdict(list)# d['a'].append(1)for key, value in pairs: d[key].append(value) OrderedDict通过OrderedDict可实现字典的按序存储（但是无法通过索引存取数据），其它与普通字典基本无差异 注：由于要维护另一个链表，OrderedDict的内存大小是普通字典的两倍，需权衡影响 命名切片python具有内置关键字slice，用于创建切片对象，可在所有使用切片的地方进行替换。可大大提高程序的可读性。用法 12345items = [0, 1, 2, 3, 4, 5, 6]a = slice(2, 4)'''下面两者等价'''items[2:4]items[a] Counter计数器Counter（from collections）。底层采用字典实现。 123456789num = [1,2,1,4,6,1,5,6,3,2,1,1,4]c = Counter(num)c.most_common(n) # n为给定整数，输出频数最高的n个元素，不给参数则整体输出c.keys()# dict_keys([1, 2, 4, 6, 5, 3])c.elements()# 可迭代对象，迭代输出为1 1 1 1 1 2 2 4 4 6 6 5 3（即按频次排序）c.values()# dict_values([5, 2, 2, 2, 1, 1]) itemgetter与attrgetter简而言之就是获取元素，等价含义如下： 1234567from operator import itemgetter, attrgetter# 下面两种等价，前者运行速度快一些itemgetter(f)lambda u: u[f]# 下面两种等价，前者运行速度快一些attrgetter(f)lambda u: u.f","link":"/2019/12/04/Python/数据结构和操作的部分库/"},{"title":"简单程序设计","text":"基操 基本语法包的导入123//import有两种导入import java.util.Scanner; //明确导入import java.util.*; //通配符导入 同一个module下的Java文件无需引用即可使用 输入输出123456789//输入Scanner input = new Scanner(System.in); //Scanner类在包java.util.Scanner中input.nextDouble(); //.nextDouble()用来读取一个double值//输出System.out.println(\"\") ;System.out.printf(\"%4.2f\", m); //格式化输出/*%d 布尔值； %c 字符； %d 十进制整数； %f 浮点数； %e 标准科学计数法形式的数； %s 字符串；*/ Scanner对象的方法 方法 描述 nextByte() 读取一个byte类的整数 nextShort() nextInt() nextLong() nextFloat() 读取一个float类的浮点数 nextDouble() next() 读取一个字符串 nextLine() 读取整行字符串 注意：为了避免错误，不要在 nextByte(), nextShort(), nextInt(), nextLong(), nextFloat(), nextDouble(), next() 之后使用 nextLine()。 输入输出重定向 123java SentinelValue &lt; input.txtjava Classname &gt; output.txtjava SentinelValue &lt;input.txt&gt; output.txt 标识符命名 只能用三类符号: 字母、数字、$ 命名不能以数字开头 常量采用字母全大写形式，在数据类型前需加上 finall 基本数据类型共有8种数据类型（数值、字符值、布尔值数据） 类型 范围 存储大小 byte $-2^7(-128)$ ~ $2^7-127$ 8位带符号整型 short $-2^{15}(-32768)$ ~ $2^{15}-32767$ 16位带符号整型 int $-2^{31}(-2147583648)$ ~ $2^{31}-2147483647$ 32位带符号整型 long $-2^{63}$ ~ $2^{63}-1$ 64位带符号整型 float 负数范围：$-3.402823510^{38}$ ~ $-1.410^{-45}$ 正数范围：$1.410^{-45}$ ~ $3.402823510^{38}$ 32位双精度浮点数 double 负数范围：$-1.797693134862315710^{308}$ ~ $-4.910^{-324}$ 正数范围：$4.9*10^{-324}$ ~ $1.7976931348623157^{308}$ 64位双精度浮点数 此外还有字符类型 char 和逻辑类型 boolean 自动数据类型转换从左到右 byte - char - short - int - long - float - double 引用数据类型 类（class） 接口（interface） 数组（array） 基本数值操作符 运算符 操作 + 加 - 减 * 乘 / 除 % 取余 Math.pow(x, y) 幂运算 逻辑运算 操作符 操作 ！ 逻辑非 &amp;&amp; 逻辑与 \\ \\ 逻辑或 ^ 逻辑异或 操作符运算优先级 操作符 优先级依次降低 var++, var— 最高级 +, -, ++var, —var (type) ! *, /, % +, - &lt;, &lt;=, &gt;, &gt;= ==, != ^ &amp;&amp; \\ \\ =, +=, -=, *=, /=, %= 最低级 转义符 转义符 含义 \\b 回退一格 \\t Tab \\n 换行 \\f 换页 \\r 回车 \\\\ 反斜杠 \\&quot; 双引号 character类判断字符类型 方法 功能 isDigit(ch) 判断字符是否为数字，是则返回true，否则返回false isLetter(ch) 是否是字母 isLetterOrDigit(ch) 是否为字母或数字 isLowerCase(ch) 是否是小写字母 isUpperCase(ch) 是否是大写字母 toLowerCase(ch) 返回字符的小写形式 toUpperCase(ch) 返回字符的大写形式 字符串Java中字符串为String类型，String类有如下方法： 方法 描述 length() 返回字符数 charAt(index) 返回指定位置的字符 concat(s1) 将本字符串与字符串s1进行连接，返回新字符 toUpperCase() 将字符串转换成全大写字符的字符串并返回 toLowerCase() 将字符串转换成全小写字符的字符串并返回 trim() 去掉字符串两边的空白字符并返回 equals(s1) 是否等于字符串s1，是则返回true equalsIgnoreCase(s1) 不区分大小写，判断是否等于s1 compareTo(s1) 比较大小，大于、等于或小于，分别返回大于0、等于0、小于0的整数 compareToIgnoreCase(s1) 不区分大小写，同上 startsWith(prefix) 是否以prefix作为前缀开始 endsWith(suffix) 是否以suffix作为后缀结束 contains(s1) s1是否是字符串的子串 substring(beginIndex) 返回 从位置beginIndex到字符串末尾 的字符串 substring(beginIndex, endIndex) 返回从beginIndex到endIndex（不包含endIndex处的字符）的字符串 补充： 将数值型字符串转换成数值 Interger.parseInt(intString) 转换成整数 Double.parseDouble(doubleString) 转换成双精度浮点数 数值可与字符串进行连接构成字符串 String s = number + &quot;&quot;; 获取时间显示当前时间可通过调用 System.currentTimeMillis()， 该方法返回的是从UNIX时间戳（1970年1月1日00:00:00）到当前时刻的毫秒数 软件开发过程 需求规范 需求分析 系统设计 实现 测试 部署 维护","link":"/2019/09/27/Java/简单程序设计/"},{"title":"类和对象","text":"面向过程范式重在设计方法。面向对象范式重在对象和对象的操作，结合了面向过程范式的功能以及将数据和操作集成在对象中的特点。 重点：面向对象思维 面向对象程序设计的三大支柱：封装、继承、多态 能有助于高效开发GUI和大型软件系统 类和对象的若干细节类是一个模板、蓝本或是合约，用来定义对象的数据域及方法 一个对象是类的实例，创建实例的过程称为实例化 Java类通过使用变量来定义数据域，使用方法来定义动作 构造方法Java类提供了构造方法，可调用它构造一个新的对象，主要是为了完成一些初始化工作，作用是初始化对象。构造方法名与类名相同，参考Python的__init__()及其参数设定 特性： 必须具备与类相同的名字 没有返回值类型，也没有void，举例： public Circle(){ } //没有返回值类型，方法头只有修饰符、方法名和参数列表 是在创新对象时通过new进行调用的 当不定义构造方法时，会隐式定义一个方法体为空的无参构造方法，也称为默认构造方法 匿名对象类似与前面提到过的匿名数组，只是省去了定义过程，直接进行了对象创建，使用时可同时调用其方法，省去不必要的步骤。如： new Circle(5).getArea() 静态变量、常量、方法要点：静态变量（也称类变量）可被类中所有对象共享，静态方法（也称类方法）不能访问类中的实例成员。且无需创建对象就可调用静态变量和静态方法。 诚然，实例对象也可以访问静态变量和方法 UML中静态变量、常量、方法以下划线标注，定义时以修饰符 static 修饰定义即可，常量则再加上 final ，比如： final static double PI = 3.1415 可见性修饰符补充：package (default) public private protected 修饰符及可见性描述： 修饰符 可见性 (default) 可被同一个包中的任一类访问，仅限同一包之中（也称包私有或包内访问） public 能被任意其它类访问 private 限定只能在自身的类中访问 protected 限定只能子类访问 注： ｐrivate 只能应用在类的成员上。修饰符 public 可以应用在类或类的成员上。局部变量上使用修饰符 public、private 会导致编译错误。 数据域封装为了同时保证数据域的封装和数据安全修改，一般通过一个 get 方法进行数据的获取，通过 set 方法进行数据的修改。 其中 get 方法称为访问器（accessor）， set 方法称为称为修改器（mutator）。 1234public returnType getPropertyName(); //get的常规定义public boolean isPropertyName(); //当返回值是boolean类型时的常规定义public void setPropertyName(dataType propertyValue); //set的常规定义 不可变对象不可变对象需要满足以下三条要求 所有数据域（属性）都是私有的 没有 set 方法 没有一个 get 方法方法会返回只想可变数据域的引用 this引用在引用隐藏数据域以及调用一个重载的构造方法时，this引用是必须的 this是指向调用对象本身的引用名，可通过调用 this引用对象的实例成员 注：Java要求 this 放在其它可执行语句之前 类中的关系 关联。 描述两个类之间的活动，uml中采用实线表示 聚合。描述两个对象的归属关系，所有者对象称为聚集对象，其类称为聚集类，从属的则是被聚集对象，被聚集类。（一个对象可被多的聚集对象拥有）。uml中用空心菱形表示 组合。一个对象只归属一个聚集对象，那它和聚集对象间就是组合关系。uml中用实心菱形表示 继承。通过一个定义的通用类（父类、超类、基类），扩充该类为一个更加特定的类（子类、扩展类、派生类）的操作。 继承与组合：继承是 “is-a” 的关系建模，而组合是 “has-a” 的关系建模 基本数据类型与数据包装类Q：为什么要将基本数据类型作为对象处理？ A：Java中某些方法的参数必须是对象 Q：为什么通常情况下基本数据类型不作为对象来处理？ A：处理对象需要额外的系统开销，会降低语言的性能 基本数据类型对象类（也称数据包装类）： Integer Byte Short Float Double Character Boolean 这些对象类所属包：java.lang 装箱（boxing）：将基本类型值转换成包装对象的过程 开箱（unboxing）：将包装对象转换成基本数据值的过程 继承与多态继承语法如下： 12//此处例子为Circle类继承GeometricObject类public class Circle extends GeometricObject 不同于this 对调用对象的引用，super指的是这个关键字所在类的类（与this相同，super也应该写在构造方法的第一条语句处），使用途径： 调用父类的构造方法（子类能继承父类的属性、普通方法，不能继承其构造方法） 调用父类的方法（一般用于方法的重写） 如果子类的构造方法中没有显式调用父类构造方法，编译器就会自动地将super()作为构造方法的第一句，如下： 12345678//下列两者等价public ClassName(){ statements;}public ClassName(){ super(); statements;} 注：静态方法无法被覆盖，如果父类中定义的静态方法在子类中被重新定义，那么在父类中定义的静态方法将被隐藏，可通过SuperClassName.staticMethodName调用隐藏的静态方法。 方法重写与方法重载 方法重写指两方法具有相同的签名（方法名和参数列表）和返回值，发生在继承关系的不同类中 方法重写指两方法具有相同的方法名，但参数列表不同，可发生在继承关系的不同类中，也可以发生在任何一个类之中 通常在方法重写前加上重写标注：@override，以表明接下来的方法为重写方法，要注意的是加上该标注后，后面的方法必须要重写父类的一个方法，如果没有重写方法，则会出现编译错误。 toString方法与equals方法由于所有没有显式继承关系的Java类都继承于java.lang.Object，而该类中有方法toString()，所有所有类都会继承该方法，默认下System.out.print(object)等价于System.out.print(object.toString())，如果要返回特定的信息，就需要改写该方法。 此外，java.lang.object中还有一个方便、常用的方法：equals()，用于测试两个对象是否相等 而==用来比较值是否相等 注：重写equals方式时，应该这样：equals(Object obj)，而不是equals(SomeClassName obj) 多态多态指父类的变量可以指向子类对象 一些解释：每个子类实例既是自身的实例，也是其父类的实例，而其父类的实例不能是子类的实例。即使用父类对象的地方都可以使用子类对象。 动态绑定描述：方法在沿着继承链的多个类中实现，JVM在运行时决定调用那个方法 具体调用哪个方法取决于 对象的实际类型，而非声明类型 如果实际类型中实现该方法，则沿着继承链依次向前，找到的第一个就是JVM将调用的方法 类型转换要点：隐式转换(implicit casting)显式转换(explicit casting) Q：为什么需要类型转换？ A：因为虽然声明类型不等于实际类型，但是声明类型决定了JVM在编译时具体匹配的方法 一个子类的实例总可以转换成一个父类的实例，该操作称为向上转换（upcasting），为确保转换的正确性，可在转换前加上一个判断操作：isinstanceof（注：isinstance并不是一个方法，而是一个运算符，用于两个对象，使用举例如下代码块） 1Circle isinstanceof GeometricObject; //其结果为boolean型 注：由于.操作符优先级高于类型转换，所有需要将类型转换与对象名用括号括起来，使之先于.操作 注：对于对象引用和基本类型值而言，类型转换的操作有所不同，对基本类型值进行类型转换会返回一个新的值，而对对象引用进行类型转换并不会创建新的对象，而是指向同一个对象。 关于声明类型与动态绑定的一个说明对了一个继承关系：Parent类和Child类， 声明Parent p = new Child()，那么p的声明类型为Parent，实际类型为Child，由于声明类型的缘故，p不能调用出现在Child而不出现在Parent的方法；而对于两者都有的方法（同一签名的方法），由于动态绑定的缘故，p会调用Child类中的该方法。 如何防止拓展和重写要点：利用final修饰 被final修饰的类和方法是无法被拓展的。被final修饰的类称为最终类，无法被继承，常见的最终类有：Math String StringBuilder StringBuffer等。被final修饰的方法称为最终方法。 常用类BigInteger和BigDecimal类作用：表示任意大小和精度的整数或者浮点数 方法： add subtract multiple divide remainder compareTo 所属包：java.math 12345678910//创建及使用BigInteger element = new BigInteger(String); //注：只接受String类参数BigDecimal element = new BigDecimal(String);//使用举例BigInteger a = new BigInterger(\"293726028508236\");BigInteger b = new BigInterger(\"3253259723\");BigInteger c = a.multiply(b);BigDecimal d = a.divide(b, 20, BigDecimal.ROUND_UP); //控制精度，此处为保留小数点后20位，舍入方式为BigDecimal.ROUND_UP的BIgDecimal对象 String类特点： 不可更改。一旦创建，其内容无法改变 限定字符串对象：为提高系统效率节约内存，对于相同字符序列的字符串，Java虚拟机使用同一个实例 123String s1 = \"hello world\";String s2 = \"hello world\";System.out.print(s1 == s2); //输出为true,即两个\"hello world\"在系统中为同一个字符串对象，也称限定字符串对象 字符串与数组间的转换： 1234char[] chars = &quot;Java&quot;.toCharArray();String str = new String(new char[]{&apos;J&apos;,&apos;a&apos;,&apos;v&apos;,&apos;a&apos;});String str = String.valueOf(new char[]{&apos;J&apos;,&apos;a&apos;,&apos;v&apos;,&apos;a&apos;}) 将字符和数值转换成字符串： 利用连接符号 + 利用 String 类的静态方法 valueOf 字符串的格式化： 123456String.format(format, item1, item2, ..., itemk);//举例如下String s = String.format(\"%7.2f%6d%-4s\", 45.446, 12, \"AB\");//注：以下两种形式等价：System.out.printf(format, item1, item2, ..., itemk);System.out.print(String.format(format, item1, item2, ..., itemk)); StringBuilder和StringBuffer类要点：此两类类似与String类，区别在于此两类是可变的； 一般而言，任何需要使用字符串的地方，都可以使用这两类，且比String类更加灵活。 两者的使用区别：多任务并发访问情况下，采用StringBuffer，而如果是单任务访问，StringBuilder则更有效果（StringBuffer中修改缓冲区的方法是同步的）。 所有能使用StringBuilder的地方都可以使用StringBuffer。 ArrayList类要点：一种泛型类，可用来存储对象的数组，数组大小可变 泛型类解释：以ArrayList为例，ArrayList为泛型类，具有泛型类型E，创建时，可执行一个具体的类型来代替E 123456//创建ArrayList&lt;java.util.Data&gt; dates = new ArrayList&lt;java.util.Date&gt;();ArrayList&lt;String&gt; cities = new ArrayList&lt;String&gt;();//JDK1.7开始，下列两者等效，此特性称为推导类型ArrayList&lt;AConcreteType&gt; list = new ArrayList&lt;AconcreteType&gt;();ArrayList&lt;AConcreteType&gt; list = new ArrayList(); 比较有用的几个方法： Arrays.aslist()：传入一个数组对象，会返回一个列表，该列表可以传递给ArrayList用于构造ArrayList ArraysList.toArray()：用上面一个作用相反，将ArrayList变为数组对象 java.util.Collections.sort()：用于可元素可比较的列表，可将其对元素进行排序 java.util.Collections.max()：返回列表最大元素 java.util.Collections.min()：返回列表最小元素 java.util.Collections.shuffle()：可随机打乱列表的元素 注：可以通过Object.getClass()放回对象的对象类型信息 其它常用Java类Data类 Random类 Point2D类 Integer与Double类 抽象类和接口抽象类要点：有时候，当一个父类设计得过于抽象，以至于没有任何具体实例时，这种类称为抽象类。 抽象类无法用于创建对象实例；可包括抽象方法，这种方法的具体步骤将在子类中实现 在UML中，抽象类名用斜体字体表示 抽象类的签名中，需要加上abstract关键字 抽象类的构造方法应该是protected的，以确保只能被其继承子类所调用 继承抽象类的子类如果不是抽象类，则必须具体实现抽象父类中的所有抽象方法，如果无法实现抽象父类的所有抽象方法，那么子类就应该是一个抽象类 父类是非抽象类，子类也可以定义为抽象类 满足以下任意条件的类就是抽象类： 显式地包含了一个抽象方法的声明 父类声明的抽象方法为在该类和其父类中实现 父接口中声明或继承一个方法，且类中未声明或继承一个方法来实现它 类中有一个未实现的方法（**自定义或继承） 抽象方法的好处： 抽象类中写抽象方法后，可以以抽象类声明某个子类，然后通过动态绑定来绑定具体的实现方法 接口要点：只包含变量和抽象方法的，与类相似的结构。是公共静态常量和公共抽象实例方法的集合 可看做一种特殊的类，与抽象类相似，无法创建实例。类与接口之间的关系称为 接口继承，也简称为继承。 接口之间的继承可以是多继承，一个类可以实现（关键字implements）多个接口 接口中所有数据字段都隐含为public static final，所有方法都隐含为public abstract 12345678/*修饰符 interface 接口名{ 常量声明 方法签名}*/modifier interface InterfaceName {} 常用几个接口（都包含在包java.lang中）： Comparable Cloneable 为空接口，（空接口称为标记接口） Runnable","link":"/2019/09/27/Java/类和对象/"},{"title":"一只特立独行的猪","text":"读书笔记 一只特立独行的猪评终于，在这周三的晚上十一点半（回忆中的大概时间，写详细会假装有感觉一些）看完了王小波的这本书，是本散文、杂文集。这个描述只是恰巧脑子里冒出了这两个词：散文、杂文， 至于描述的正确性和这两者的差异性，我是不清楚的。 这本书，我想不会是由王小波自己编撰，极大概率是去世后亲戚或者出版商根据他的一些文章整理编撰的。从部分文章从内容可以看出是写给某报刊或书评的，还有些是径直摘录的王小波部分小说的书序内容。另外，绝大多数文章和沉默的大多数里是相同的，也算是重温了，部分重复的文章内容不是特别感兴趣就跳过了。 王小波的文章深深地承载着他个人的思想，这些文章也透露着他对读者尤其是青年一代的关怀，把许多知识分子潜在共识但少有表达的思想跟读者交付了一通，附带着自身的自由、批判、独立思想，担负起了青年人导师的责任，至少对我是如此，陆陆续续给了我很多启示和个人改变。 王小波的作品贡献，我认为在于一种思想和观念的传递，而不是纯文学方面的（不过什么又叫纯文学方面呢），这种感觉很难完整抒发出来，可能是因为作品好但是不够好吧，当然这也不是个人所能决定的，当时的社会环境和个人生活条件也是有所制约的。 之后可能不会再读王小波的散文（杂文）集了，一是已经看过几本，对他的一些思想大致都进行了了解（不是理解），再看下去可能也无益，以后会更多地去尝试中长篇小说，再者就像他写道的： 千万别听任何人讲理，越听越糊涂，任何一门艺术只有从作品里才能看到。套昆德拉的话说，只喜欢看杂文、看评论、看简介的人，是不会懂得任何一种艺术的。——王小波 一朵美丽的鲜花，并不是你停止去发现更多美好事物的理由。美丽反而也会成为一种陷阱。 摘文字是用来读、用来听，不是用来看的——要看不如去看小人书。 我们年轻时都知道，想要读好文字就要去读译著，因为最好的作者在搞翻译，这是我们的不传之秘。 昆德拉说：不懂开心的人不会懂得任何小说艺术，除了懂得开心，还要懂得更多，才能懂得小说的艺术。 这种情形对我是一种极大的损害，在此我毫不谦虚地说，我是个高层次的读者，可是书刊检查却拿我当十六岁的孩子看待。 读书人喜欢做的事情是埋首于故纸堆里，好像故纸之中什么都有了。中国的典籍倒是浩若烟海，但假若没人把事实往纸上写，纸上还是什么都没有。 人忠于已知事实叫做诚实；不忠于事实就叫做虚伪。还有些人只忠于经过选择的事实，这既不叫诚实也不叫虚伪，我把它叫做浮嚣。 古往今来读书人，从经典里学到一些粗浅的原则，觉得自己懂得了春秋大义，站出来管理国家，罔断天下的是非曲直，结果把一切都管得一团糟。 老百姓说：罐子里养王八，养也养不大。 优秀文体的动人之处，在于它对韵律和节奏的控制。 自文言体之后，影响最大的文体应该是苏晓康写报告文学的文体，或称晓康体。这种文体浮嚣而华丽，到现在还有人模仿。念起来时最好拖着长腔，韵味才足，并且好用三个字的词组，比如“共和国”、“启示录”之类。在晓康体里，前者是指政府，后者是指启示，都属误用。晓康体写多了，人会退化成文盲的。 家庭也好，海船也罢，对个人来说，是太小的囚笼，对人类来说，是太小的噩梦。更大的噩梦是社会，更准确的说，是人文生存环境。假如一个社会长时间不进步，生活不发展，也没有什么新思想出现，对知识分子来说，就是一场噩梦。 在美国，教会、军队，还有社会的上层人物，受宗教和等级观念制约，时常犯有假正经的毛病，所以就成为嘲讽的对象。这种幽默中国没有，但却不难理解。中国为什么没有这种幽默，道理是明摆着的：这里的权力不容许幽默，只容许假正经。 根据我的人生经验，假如你遇到一种可疑的说法，这种说法对自己有过于有利，这种说法准不对，因为它是编出来自己骗自己的。 人生在世，常常会落到一些“说法”之中。有些说法是不正确的，落到你头上，你又拿他当了真，时过境迁之后，应该怎样看待自己，就是个严肃的问题。 现在我想，人活在世界上有两大义务，一是好好做人，无愧于人生一世。这一条我还差得远。另一条是不能惯别人的臭毛病，这一条我差的更远。 在我们年轻时，每一年的经历都能写成一本书，后来只能写成小册子，再后来变成了薄薄的几页纸。现在就是这样一句话：读书、写作。一方面是因为我们远离了动荡的年代，另一方面，是因为我们也喜欢平淡的生活。对我们来说，这样的生活就够了。 一位法国政治家说过这样一句话：一个人在二十岁时如果不是激进派，那他一辈子都不会有出息；假如他到了三十岁还是一个激进派，那他也不会有什么大出息。我们这样理解他的话：一味的勇猛精进，不见得就有造就；相反，在平淡中冷静思索，倒更能解决问题。 我对权利没有兴趣，对钱有一些兴趣，但也不愿意为它去受罪——做我想做的事（这件事对我来说，就是写小说），并且把它做好，这就是我的目标。我想，和我志趣相投的人总不会是一个都没有。 人在工作时，不单要用到手、腿和腰，还要用脑子和自己的心胸。人必须过他可以接受的生活，这恰恰是他改变一切的动力。人有了心胸，就可以用它来改变自己的生活。 虽然人生在世会有种种不如意，但你仍可以在幸福与不幸中作选择。","link":"/2019/11/29/个人/一只特立独行的猪/"},{"title":"九月月记","text":"第一月小结 开学9月3号，匆匆忙忙地叫了个货拉拉，把暑假放在航哥那的行李加上自己都给运到了学校，说来也是很无语，第一次坐车过来，不知道哪个门让进，结果就是：走了三个地方的门，都不让进，最后在某门卫的指引下，绕了一圈终于从东大门进了（以前都不知道还有这个门）。连续几天忙碌后，总算是安定了下来。中途有几个印象深刻的活动：开学典礼、班级班会，开学典礼第一次见到了李元元校长，隔得比较远，其实看得也不太清楚，朦朦胧胧的一个印象，讲话内容也没太多值得回忆的，也可能是午饭吃多了，导致丢失了部分记忆。开学典礼上至今还有一些印象的要数来自材料学院的导师代表讲话，不愧是导师代表，讲话和蔼中带着鼓励，讲话的内容也说不上来了，只记得一句：“每代人有每代人的长征”，给我留下的印象也亦如此。后来还有两句话让我颇有受益，一句是廖老师说的，做事之前多考虑各种大大小小的情况，做起事来的时候才能比较轻松一点；另外就是班级班会，说起班会，真是开了老半天，都是由于书记和辅导员在场，提了各种自我介绍的要求，介绍完之后顺带着选了班长和团支书，期间书记说了一句话：不要有脆弱的自尊心，用在我身上极为适合。 宿舍环境研究生新生活，从室友到宿舍配置，都比较不错，真是舒服了。终于，宿舍有了完整的洗漱台，而且装修得挺好，最令我满意还是热水了，正式结束了四年的澡堂生涯，作为一个磨磨唧唧的人，宿舍热水配置真是刚需。 上课由于2.5年学制的安排，选课要求是40个学分，而且，还要补修两门计算机课程，应该是很充实的研一的，顺便沉浸在对实验室的向往中，比较也从没真正加入过实验室，感觉实验室生活还挺新奇。 月底总结正式选好导师之后，反倒情绪低落了一些，可能是内心还是希望能做点事吧，好不容易读个研究生，万一研一混着过去了就很伤人心了。来学校之后，原来的看书计划就慢慢开始停滞，就上半月看了三本书：只是孩子、民主的细节、杀死一只知更鸟，下半个月由于各种打算和环境因素作用下，看书进度开始龟速向前，只能安慰自己说：可能是书的题材问题？希望吧，下个月尽量看完5本书吧。学习方面，只能说都了解了一下吧，至于真真确确学到的，可能也不尽人意，一会看Python爬虫，一会看Java基础，偶尔又去学机器学习了，还是过于随意，下个月得或多或少做出点计划了在学。不过最近几天还挺有成就感，搭好了博客，学会了Git的基本操作，下个月争取把SQL给学了，在熟悉一点Android开发，不然课程作业做不了了。来学校之后，之后比较规律的运动习惯也分崩离析，过了两周之后才发现没跑过步，时至今日，这个月一起跑了3次，囚徒健身上学到的锻炼倒是还坚持了有七八次的样子。由于导师选好之后也没说什么任务或者关于实验室安排的事，这个月大部分不上课的时间都是在宿舍睡觉和coding，“码”不停蹄，却没有什么收获，倒是提前进入了996状态，还是希望到时候毕业能找个好工作吧，比啥都强。写到这差不多了，口水式记录，没办法哦，多看书吧。对了，前几天出去看电影很开心。","link":"/2019/09/30/个人/九月月记/"},{"title":"冬泳","text":"《冬泳》——班宇 评第一篇比较精彩，孙旭庭整个人生的转动、性格的转变呈现得清晰而透亮，说是最精彩的一篇也不为过，可能这也是放在开始的缘故吧，就像阿乙的《鸟看见我了》第一篇，好像叫意外杀人事件，写得是最为精彩，其实这两本书类型倒是很像，故事类型、结构也是。 盘锦豹子，豹子是孙旭庭的外号，青年时期阳光积极，性格平和，一如大多上一代人青年相册中的特质和模样。故事从他娶媳妇开始，而他老婆便是此后一切生活转变的源头。在印刷厂里勤勤本本工作，表现也很为出色，随后生活也是蒸蒸日上，算是那个年代较为富裕的家庭了。转折来自他妻子，在物质满足后，开始了大半生的麻将之行，并将其视为人生的下一个追求，之后便离开家了，跑到大城市兜兜转转，开了麻将馆，后来经营不善甚至回家拿走房产证在外做了抵押。满心沉闷的孙旭庭一次工作中心不在焉地断送了自己一条胳膊，也开始逐渐放纵和颓废，从一个对生活憧憬满满的青年到一个日益颓砣的中年，儿子也无心学习，几次高考未果后便再无兴趣。幸好人生中遇见了做按摩的小徐师傅，组建了第二个家庭，在面对上门想收房的陌生人时，终于把一切都爆发了出来，光着臂膀，拿着菜刀冲下楼梯喝走了不速之客，故事也在楼上小徐师傅的哭声之中结束。 书里的故事都比较纪实，故事大多以下岗潮的背景，不同的地方、不同的家庭，大多相似的境遇，原来刘欢的从头再来就是献给这个背景，可谓是激励了不少人，“昨天所有的容荣誉/已变成遥远的回忆/辛辛苦苦已度过半生/今夜重又走进风雨…”。《冬泳》的文体相较其他同背景故事的小说而言，会显得更加文艺、富有情怀，没那么接地气，有些地方也显得故意堆砌，总体效果还是挺好，这一套文体把几个核心场景构建得意味深远，读完后脑子里略有回环。整体而言确实值得一读，读故事、读文字、读背景。差不多到这了，也该继续学习算法去了。 摘孙旭庭双手举到最高处，咬着牙绷紧肩膀，凉风吹过，那只行动不便的残臂仿佛也已重新长成，甚至比以前要更加结实、健硕，他使出毕生的力气，在突然出现的静谧里，用力向下一掷，震耳天空长嚎一声，哭的不省人事。 学校里迎来有一次的百日誓师大会，所有人的脑门青筋暴露，举着拳头要奋斗一百天，而表弟书桌上去年的标语还没有撕掉：披荆斩棘，看我旭东决胜高考；立马横刀，唯我旭东俯视群英。 孙旭庭扭头开门，走进屋子，留下小徐师傅孤零零地站在走廊上，她不敢迈步，也不敢说话，孙旭庭那条僵硬的残臂从她怀里抽去之后，她一下子变得无所依靠，身前身后空空荡荡，风吹过来，塑料珠子门帘哗哗作响。 这时，小徐师傅的哭声忽然从头顶上传过来，他们父子躺在楼梯上，静静地聆听着，她的哭声是那么羞怯、委婉，又是那么柔韧、明亮，孙旭东说，他从来没有听见过那么好听的声音，而那一刻，他也已看不清父亲的模样。 车沿着大道开起来，头发被风梳在后面，两侧的风景飞速后移，袖口里灌进几分凉爽，满目生机。 青春期下乡，中年有下岗，本想顺应时代洪流，成为其中微不足道的一员，但到最后才发现，只有自己四处碰壁。 我被人群簇拥着走出医院，外面正下着小雨，温热的雨水落在地面上，很快又蒸发掉，不留任何痕迹，随着他人的目光，我望见马路对面有阵阵黑烟上升扩散，蓝绿色的火焰缭绕，如同闪电一般迅疾而易逝，铁的骨架在其中若隐若现。半空里火花闪现，雾气之中有触手一般的阴影来回甩动，惊恐、凄厉而无助的喊叫声也从中传来，无法分辨性别，我们所有人在路的另一侧沉默地注视着，灾难在眼前逐渐变得具体起来。 我光着脚走上跳台，站在高处，俯视着下面的人，隋菲在最远处，跟她的影子融为一体，我大喊一声，人们望向我，然后我迈步上前，挺直身体，往下面跳，剧烈的风声灌满双耳，双臂入水，激起波浪，像要把池水分开，这是今天的第一跳。 我和她们一块走过铁道，不慌不忙，速度很慢，像是标准的三口之家，前方仿佛有着整整一生的时间，在等着我们度过。火车在我们身后缓慢开去，轰隆作响，替我们挡住一阵吹起来的风雪。 云层稀薄，天空贫乏而黯淡，我一路走回来，没有看见树、灰烬、火光和星系，岸上除了我之外，再无他人，风将一切吹散，甚至在那些燃烧过的地面上，也找不到任何痕迹，不过这也不要紧，我想，像是一场午后的散步，我往前走一走，在走一走，只要我们都在岸上，总会再次遇见。 走出疗养院一楼的大门，站在院子中央，空气清冷，背后是石砌成的拱顶，抬头望去，远处的山峰与阴云连接在一起，灰烬一般的颜色，他仿佛正处于峡谷的中央，而风带来轻微的回声。 他们共处在一辆缆车里，坐在两侧，乌云很近，抬手可及，李承杰背对着山峰，目不转睛地看着两侧逆行的风景，班立新只注意到那片乌云，柔韧而慢散，他从来没有这么近接触过任何一朵云彩，他想，闪电会不会也在其中，然后他就看见了闪电，天上的一道光，在他眼前聚集、分解、消逝，伴随着巨响，他闭上眼睛，但闪电的模样仍停留在那里，长久不散。 有些人来了，有些人走了，发生了一些事；至于我，我总在这里，总在星星照耀之下。 树挪死，人挪活，别太担心，总有出路。 那时，他们都还没意识到，这是多么悠长的一个夜晚，他们两手空空，陡然轻松，走在梦境里，走在天上，甚至无需背负影子的重量。 天空呼啸，夜晚降落并碎裂在水里，周围空空荡荡。我知道有人在明亮的远处等我，怀着灾难或者恩慈，但我回答不出，便意味着无法离开。而在黑暗里，河水正一点一点漫上来。 去西方，一起上西天，展翅高飞，跟鱼和海鸥们一起，吃海草和虾，呼朋唤友，在咸而潮湿的空气里，夜航西飞，去往海的尽头，生活的尽头。 老孙眯着眼，跟着节奏轻轻摇摆身体，身下的弹簧沙发有规律地涌出一团团的灰尘，像水中金鱼吐出的泡泡，迎着最后的几缕阳光，膨胀，飞舞，破灭，消散。 夜海磅礴，贫瘠的山峰隐藏在月影里，恰如礁石，一闪而过。","link":"/2019/12/20/个人/冬泳/"},{"title":"十一月周记（第三周）","text":"日常周记，此篇包括了十一月第二周和第三周 很不幸，上周又鸽掉了周记，算了，也不想专门补了，这边周记顺便回忆一下上周零星内容。 上周掠影上周末跟初中同学吃了顿饭，大概已经有五六年没见过面了，见面大家都还是很熟悉的模样，可能是已经定型了，顺便也体会到了些许一见如故之感。 上周晚上真是异常忙碌，连着三天晚上上了党课，一天晚上吃饭，周末还要疯狂赶大作业报告，很难想象之后连着几场考试的日子是怎么样的。 有一天晚上回宿舍，背着书包坐在凳子上，打开了苏童的《妻妾成群》，很早有所耳闻张艺谋的大红灯笼高高挂是改编于此，不过书和电影都没看过。好在书不长，连续一个小时就看完了，整体来说还是挺好看，整个旧式封闭家庭环境构建地很细腻，结局很有撼动感，在这种环境下作为女性真是不容易，需要费尽心思才能维持地位，尽管仍然难以得到真正的快乐。环境是如此深刻、深远地影响人的性格，虽然常说环境和性格相互影响，但我看到的大多是性格适合和习惯了环境。 此时此刻现在是这周第五天，11月15号，下午不到两点，这周还剩一节课，就是今天下午第二节，紧接其后的是一项团体活动——班级聚餐，火箭1901班第一次大聚首，在开学两个半月时。 又到了一个月的15号，感觉又开始混时间了，今年余额渐渐不足，看到自己现在的各方面水平和剩下的科目考试，不禁有点悲伤，流下了没钱没技术的眼泪。 尽管如此，周末还是想着能够有些活动，原本计划的活动很不幸又落空了，决定去余家头逛上一趟。 随便提一提昨晚的考试，本来大作业就已经不太容易了，还“贴心”安排了一场考试，说是走个形式、对着ppt抄上五题就可以，昨晚从头到尾翻完打印的PPT好几遍，还是一题找不到，可能是让我们适应下紧张的考试氛围？ 写到这，此次周记也算是告一段落，正好看完了两集生活大爆炸，今天已经开始看第七季了，并且这周已经用实验室的WiFi缓冲了后面直到12季所有的视频。这周剩下的几天，尽力写下几篇学习文章、尽可能地推进统计学的学习进度、重新开始做日常规划！","link":"/2019/11/15/个人/十一月周记（第三周）/"},{"title":"十一月（第五周）","text":"日常周记 心情复杂忽然起来的降温，从周一开始，温度直降十度，本来今天有一节数学课，实在是不想去了，眼看着三个室友的身影离开宿舍。之后去实验室去复习了会数据结构和数据库，无奈穿的短袜实在是冷，中午吃过午饭就又回宿舍了，并且把电动车停到了停车棚最里面，一直到周五都没再碰了。 这周气温真的是让人难受，基本上一周都是十度以下天气，去西十二课是最考验人心的了。这周二下午听了学长学姐关于工作、国奖和选调生政策的介绍，刚好有一个学长也是算法方向，讲得也挺认真负责，让我所获甚丰，也又开始意识到自己进度真是太慢了，挨过三选二的考试之后得好好指定一下长远的学习路径安排了，着实很羡慕学长的境遇。还是那句话，临渊羡鱼，不如退而结网。 新收获这周发生了些许变化，生活中又多了一些新的目标和方向，希望自己能兼顾各方面的生活并且能做好想要做的事。 这周也算是看完了王小波的一只特立独行的猪，很多内容和沉默的大多数是相同的，也算是温故知新了，再次体会他如沐春风的思想和文字。其中有两篇关于文体和格调的文章给我带来了些影响，看完发现一直以来我都处于一种刻意构造某种文体的状态，不够真实甚至很装，之后追求的文字状态可能更为平淡清一些，更加符合自己的水准。碰巧这周抽出了将近一小时时间翻完了所有的QQ动态，幸好以前没有都删掉，给了我不断审视自己的机会，也好继往开来，实话说，以前真是有些矫情有些做作。 这周跟别人交流的时候，突然意识到了自己的一个潜在人生理念：做一个温暖的人，永远相信生活的美好。跟别人可能骨子里还是有些理想主义和文艺气息倾向的，不过很难当个引领者了，毕竟思维过于局限，性格过于软弱。","link":"/2019/11/28/个人/十一月（第五周）/"},{"title":"十一月周记（第一周）","text":"十月份的尾巴，十一月的前奏，可我不是天蝎座 严格来说这周属于十月份，因为绝大多数时间都是在十月，只是周末发生在十一月，划在十一月有两个原因：一是它的确是在十一月结束，二是我还没做好写周记的准备。显而易见，后者是主要原因。 周一到周四没什么好说的，平淡一如往常，以至于我得好好回想才能想到，这几天是否发生过什么有趣的事，有趣的事这个词，似乎滥用之后所描述的大多并不是有趣的了，只是不同寻常之事，可能更应该叫新鲜事？想了又想，似乎的确没有，那只能看看周五到周日这几天了。 开会为什么周五会单独拎出来呢，当然是运动会咯，十一月一号，似乎都喜欢选这一天作为运动会。既然是运动会，那天气自然是不错，而很可惜，原定的向日葵之旅有变未能举行，这一天却也不是悄然离去，前一晚导师通知了这天上午学长会进行工作汇报，我们这级三个留实验室的也就都给叫上了。 三点影响这次开会对我有好几点影响，归纳起来有三点吧，第一就是带给我了早餐和上午时光（尽管上午时光已经被安排完了）。九点准时开始了流程，主体内容便是五位学长轮番上去汇报，坐在电脑桌前，结合PPT讲解近期工作，期间老师稍作指点和说明。 讲完之后我也大致清楚了工作内容，即我将面临的学习内容，这便是第二点影响了。内容似乎很充实，也很还处理，毕竟是偏学术的，也没办法了，还是找工作重要，好好研究争取顺利就业。 学长们汇报完之后，导师上台算是做了个总结，也再叙述了一下课题内容和细分方向，主要列出了三个（毕竟我们这一届仅三个人）细分方向，说罢让我们考虑考虑，每人择一而为。这就是第三点影响了，选择研究方向，三选一。 意外的安排要说这次开会还有其它影响吗，的确还是有的，比如发现我们实验室搭建起了一个分布式集群供计算工作所需。是由某一个学长亲力亲为，几乎以一己之力搭建而成的，而汇报间隙，导师突然说了句，让我以后负责这个系统的运维工作，毕竟学长研二下学期就面临论文和择业了。这个工作倒也和我心意，顺带着能继续学习一下分布式知识，毕竟还专门蹭过这门课，并且以后还能亲身感受一下实体机器。 运动会周六可算是一个惨痛的回忆了，这一天上午，被安排着去西操场学院帐篷下负责运动员接洽和后勤工作。前一晚熬夜看了几个视频，今天又是八点多起来的，明显感觉身体吃不消。 说起来真是惨痛而且无以形容，我跟另外一个女生，负责将我们年级两个女生带进比赛场地，而我实际又不知道地方，迷迷糊糊地以为是光体，便边说话边走。兜兜转转进了西操跑道，然后发现是在这比赛。但是得先检录，打完电话才知道检录是在另一个地方，而且本来是安排了一个本科生带着我们，当时猝其不意，也没注意到这茬。期间还有其它各种，比如我的各种令人无语的交流，总之异常惨淡，开始了严重的怀疑和自卑情绪，直到去图书馆还书过后，在图书馆沙发上睡上了一个小时后才算缓解了一些。 周日周日这天，一个初中同学第二次过来，我和另外一个在管理学院的同学（初高中同学，而且和那个初中同学一起都还是曾经一年的小学同学）便欢天喜地地接待了起来，在集贸了兴趣浓浓地吃了一顿，聊了半天，然后一起在外面坐了会，在校园又散了会步。欢欣而满足，六点一刻过来，最后九点之后才重回宿舍，静候一周逝去它最后的光景。","link":"/2019/11/05/个人/十一月周记（第一周）/"},{"title":"十一月（第四周）","text":"日常周记 焦急的前两天上周布置了另一个软件测试作业，还得做好PPT，周三上课就得当堂介绍，此外还得写一份思想汇报也是周三上午得交。由于没做过软件测试，就主要选了承担PPT的任务，外加一个小的测试任务。 第一天晃晃悠悠得就过去了，上了四节课，上午和晚上，下午在图书馆看了会学长发的论文（真是长，有19页…）和数理统计。直到晚上发现项目运行不起来…糟心，而第二天早上起床还感冒了，真是一波又起，很尴尬的是下午转发一篇待发布的微信推送给辅导员，辅导员直接语音轰炸，让打回重写了，庆幸这次不该我写，不然真会暴躁起来。 小小的精神世界周二晚上跟室友一起在操场跑上了五圈，比较畅快，心率一如既往偏高，但现在呼吸好不错，跑完还比较平和，不再像之前气喘吁吁。 跑完步在操场门口踱步片刻，脑子里冒出几个画面和一些记忆片段，天龙八部里段誉的凌波微步和武汉大学的凌波门，一直以来对于凌波这个词都比较困惑（对于这些理解不清晰的词甚至有一种恐惧感，可能正是这种恐惧感和自我逃避导致错失了很多有趣的知识和典故），心里默念了好几遍加上一些品味，忽然间畅快了起来，意会到了凌波之意。 凌就是浮于之上，且带有一种逸动之感，有了这点领会，凌波微步就变得具体而可视，也得以一窥凌波门之韵味。 这一小进步，给操场的我带来极大的满足和畅快，转念想到关于自我精神世界的一些问题。精神世界是极其重要的，是当你从一切环境中抽离开来所还能剩下的相伴，但它需要循序渐进的养成，而且是多方面的混合体，似乎会偏向文化方面。诸如小说、诗词、科幻想象，甚至乒乓球都是可以构成精神世界的板块，当一次次心灵独处时对这些方面的思索、自我对话和自我尝试，慢慢这颗种子便可以长大，精神世界在你的生活中也是开始长大，变成越来越日常、越来越无法忽视的一部分。精神世界丰富的人是幸福的，希望自己能够在一些方面慢慢培养起来。 提到精神世界，想到王小波写过的一句话：井底之蛙也拥有一片天空，十三岁的孩子也可以有一片精神家园。","link":"/2019/11/21/个人/十一月（第四周）/"},{"title":"十二月（第三周）","text":"日常周记 日这周第一天心情就像坐过山车一般，本来做好不参加实训的准备，甚至规划好了这阶段学习安排，结果被告知没走好流程，还是得参加，突然的苦涩，生活总是充满奇奇妙妙。 第二天就完美融入了实训生活，大清早的七点多就起床，赶到学院后再打开钉钉打卡，意外发现钉钉现在有自动打开功能，到目的地后打开钉钉就会自动打卡，这点小功能还不错，也算是难能可贵的一丝优点了。朝8点半晚5点半的上班生活，人多倒还是很热闹，每天的上午时光瞬间得到了延伸。 这周还是有些收获，比如学了HTML的基本知识，跟着bilibili的一个前端视频，准备把基本的HTML、css、JavaScript好好学习一下。另外也在跟着官方教程和一本书学习Django开发，陆陆续续了解过一段时间，这个框架似乎入门稍稍容易一些，算是python web开发的一大代表框架了。 至于实训项目，一点没动，我们组这周基本也都在复习数学，毕竟下周就要考试了，矩阵论+数理统计+两个数值分析知识点，内容比较详实。 18号晚上，我正坐在实验室位置上看数理统计，年级群里突然转发了一条成都实践招募的通知，看完之后比较动心，浮现起当时成都一游的光景。成都的确是一个挺能吸引我的城市，况且这次实践和联合成都政府一个组织，包交通费和住宿，于是便开始填问卷、填报名表，第二天找辅导员签完字就邮箱发过去了，期待一下结果。（果然，没有成功，学院就一个研二的人报名成功了） 夜记得严锋老师在微博上写过，许多人喜欢熬夜，因为黑夜才是真正属于自己的。白天，无论身在何处，总是无法刨除各种安排的束缚、环境的影响、他人的约束，而晚上则是万籁俱静，一切思想和行为都自由自在（虽然行为范围有所局限）。 慢慢地，晚上已经很少失眠了，睡得也还挺踏实，踏实到好几天没戴手环了，一晃手环都买了两年多了，当时买的时候就是以睡眠记录为主，显示时间为辅，陆陆续续都换了好几条表带。失眠少了，晚上思考的也少了，看书倒还是每周都在，现在一般一周也能看完一本书，这周看完了鲁迅的呐喊，重温了许多熟悉的画面，书后有一篇陈丹青的评语，看完才发现陈丹青已经六十多岁了，岁月催人老，每次看的陈丹青这个名字，脑海里立刻就能显现出陈丹青在圆桌派出现的场面，一对带有穿透力的双眸，仿佛正直视着你，目光如炬。 大概周三晚上，在kindle书桌上翻来翻去，终于翻开了下一本书：与罗摩相会，记得之前在哪里看到过，风评还不错，想到好久没看过科幻小说了（好像没看过几本），三体好像也就看了一本，以后抽空再看看后面几本，希望吧。 都二十号了，再过个十天时间就转到2020了，猛地听到室友说20后要出生了，20后看90后就像90后看60后，细思极恐…看来得成熟一点了，哈哈哈哈…","link":"/2019/12/20/个人/十二月（第三周）/"},{"title":"十二月（第二周）","text":"日常周记 日常这周过得还是蛮快的，考试周的确有些难熬，而且这周又有了些新计划。以下为流水账。 这周五有计算机网络的考试，老师给的重点内容是在是太多了，导致一刻不敢懈怠，从周一到周五一直都为此头疼，不过也并没因此怎么复习。老师给的PPT不仅多而且全英文，加上全是些网络知识和密码学知识，看着着实有点恶心，幸好从上一届传承下了整理好的重点问题答案。 周二晚上从五点半到八点半都是处于被安排状态，十几个研究生院中抽一个作为调研对象，我们院就这样幸运地被抽中了，周二晚上正式被调研，讲话、开会、问问题…时间就这样流逝。 周三下午所有19级研究生被召集开了个会，正式启动今年的工程实训，每组3-5人，选一个开发题目，这学期末两周半和下学期初三周时间做完选题并参加答辩。幸好早一天问了导师，得到了可以不参加实训的豁免，感觉生活变得美好了许多，可能快乐都是比较出来的吧。希望在实训同期，能好好推进ML、sklearn、django等进度…哦，对了，还有导师项目的图嵌入。 周四也也是不得闲，上周末结束的六院合办辩论赛得写一篇总结推送，这个重任最终落到了我肩上。花了（我的）一上午的时间，勉勉强强写完，效率感人，特别是文案基本是借鉴的材料学院的相关推送。 周五上午去西十二上完了这学期在这的最后一节课，不用再过来了反而有些小哀伤。现在离是周六晚九点半，明天一天得去负责一个活动的后勤工作，估计就得大半天了，这周就这样要过去了。 关于学习这周初重新捡起机器学习的学习，找了个淘宝店打印了两本书，其中一本就是邱锡鹏的《神经网络和深度学习》，又开始了筑梦工程，至于手头的一些书多久能看完，似乎也没那么重要了。 机器学习方面，这周主要跟着B站上张志华和浙大的一个机器学习视频，另外在看邱锡鹏的书和Python数据科学手册，目前最大的希望就是能尽快将知识实践起来，能做做案例的学习，刷刷算法题之类的，跟着视频和书籍，这周主要对支持向量机、集成学习和sklearn的一些操作有了新的收获，望下周在保持的基础上加快前进。对了，下周得好好开始看矩阵论和数理统计了，虽说26号考试，但任务确实不算是不重。 昨晚买了俩入门的钢笔，再一次…准备开始练练字。","link":"/2019/12/14/个人/十二月（第二周）/"},{"title":"十二月（第一周）","text":"日常周记 紧张的考试这周二晚上九点，结束了三选二考试的第二门——数据结构考试，题目比较平实。虽后差不多休息了一天，就开始准备专业课了，大致算了一下，这个月一共还有6门考试，也就是说基本上每隔四天有一门考试，实实在在的考试周就这么无声无息地开始了。 软件测试的考试，复习地真是让人头大，PPT内容繁多而抓不住重点，在差不多看完两遍PPT之后就不想再复习了，心疼打印PPT的钱。结果，周五的软件测试考试，足足到了交卷时间我才勉强写完，写了整整两个半小时，主要有两只拦路虎，一只是要求写一个函数和配套的单元测试脚本，另一个在此前的实践项目开发中抽出一个功能来列出组合测试方案，作为一个混子，我表示略微心累。 周末不得闲好不容易周五结束一门专业课考试，周末每日都还有事儿，周六一下午的上机，让写个PPT，微服务、区块链技术二选一，周日下午得作为工作人员去经济学院负责有的没的的事务。幸而微信推送任务可以挪到下周去，下周再考虑吧！ 其它马上也快工程实训了，大概在一两周之后，工程实训的开始，象征了专业课程的全部结束，也象征着这学期要到头了，而我还在机器学习的基本算法里匍匐…开始自怨自艾。 又重新捡起了吴恩达的《机器学习》网课，续上了之前的反向传播算法，看完之后突然又不想继续看了，觉着还是不大适合我，讲得过程还是浅显了点。准备抽空看看这课PPT算了，顺便加上别人整理的笔记。 在B站上一阵倒腾，找上了张志华的《机器学习导论》，抽空看了四集，不确定后面还会不会跟下去，还是希望可以坚持着看下去。这几日，思来想去还是把邱锡鹏的《神经网络和机器学习》给打印出来了，加上《Python机器学习》，在淘宝上打包花了四十，至于《机器学习》就没准备买了，这周迫切地发现得做好长期的学习规划了，all in algorithms！尽快推进，然后积极参加到网上的数据科学比赛或者做做网上的实践项目。 A field that bridge computation and statistics, with trys to information theory, singal processing, algorithm, control theory and optimization theory. ——Michael I. Jordan ML = Matrix + Optimation + Algorithm + Statistics","link":"/2019/12/08/个人/十二月周记（第一周）/"},{"title":"十月周记（第三周）","text":"日常周记 此时此刻，已经是第四周的周五，又陷入了拖延的漩涡之中，维持习惯真是得具有绝对的主动性。上周的生活并非过于平淡，只是忙中误事忘了写周记，以致于一些当时有所悸动内心的事情已经模糊，愧疚的话就不多说了。 阴郁的早晨作为上课周，首先值得关注地就是课表的变化。本周（即此时此刻的上周）多了一堂课：高级软件测试技术，据实验室一个老哥说，这节课的任课老师前些年被学生举报过，缘由居然是作业过多，当时一笑而过。想着现在作业应该不多了，而且这个老师还是我室友的导师，听说为人较为严谨负责。 第一堂课真是令我记忆犹新，非指课堂内容，而是上课路途上的艰辛。那天早晨天降大雨（那天的雨可能并没现在回忆中的大），骑着小电驴的我，披上了雨衣，一路听歌哼曲地骑到了距离宿舍3.8公里的西十二教学楼（几乎所有课都在这，课程安排让我们在东校区的着实心塞），听起来似乎平淡中还带着惬意。实际上，当天天气整体就很阴郁，路上积水时常被溅起，冷风也让人实在遭受不住，当天的风毫不留情，到课堂坐下之后我的手几近失去知觉，仿佛寒冬已至。 第一节课后，便布置了一个大作业，分组完成一个软件开发兼测试工作，有幸我被选中，和六个女生分到一个小组，一共七人的小组。据我室友说我们班统共只六个女生，听罢我的心情还是很愉悦的，平淡生活中的小确幸嘛（之后发现其实有七个女生，另外一个女生好像和六个男生分到了一组）。 生活的调剂这周不同于前几周还体现在三个地方上，而且恰好分布在三个独立日子里：周五、周六、周日。 周五，应期举办了院新生篮球赛，作为研会唯一三个男生中的一个，我扛起了搬东西的一部分重任。和一个人搭着手把叠在一起两个铁桌子从宿舍搬到操场，球赛过后又搬将回来，有一说一，挺累的。 周六，一上午上午白给，这周安排了面向对象课的上机，持续一上午，但是坐在教室后半部分的我完全听不清悠闲坐在第一排的老师在咕隆些什么。 周日，很愉悦，怀着憧憬出门，大概九点出宿舍，晚上十点会宿舍，充实和惬意。上午跑去武大跟航哥碰面，尔后中午等到他高中同学后一块吃了饭，再找了个咖啡厅聊天到下午四点，随后便分开了，跟他同学同进地铁，向相反的方向前行。回学校之后又跟着捷哥摸了摸篮球，晚饭过后，带着博哥去韵体打了俩小时乒乓球。近十一点回宿舍洗了个澡，这一周便到了尾声。","link":"/2019/10/25/个人/十月周记（第三周）/"},{"title":"十月周记（国庆周）","text":"10月第一周，恰逢国庆周 待在学校的一周，事先没做什么准备，以致于国庆买不到回家的票，只能买4号的票，想到就只能回去几天而且来回也不容易就作罢了，反正回去也是躺着。 看电影的一号周一跟着捷哥建议下，和博哥一起三个人去看了趟电影，我和我的祖国，一部水准还不错的爱国片，一共七个故事，比较喜欢徐峥导演的《夺冠》和宁浩导演葛优主演的《北京你好》，相较而言最后俩个故事看得我内心毫无波动，可能还是喜欢怀旧气息浓一些的画面，葛优的表演让电影很有代入感。看完之后发现主题曲居然还是王菲献唱，之后几天断断续续听了几遍。 看剧的三号对于一个一天开始于中午的人来说，一天总是短暂的，起床、午饭、下午、晚饭、晚上、睡觉，想到生活大爆炸第五季只看了不到一半，于是一股劲头上来，不可断绝，晚饭将行时已经看完第五季外加紧跟着的一期特别采访。 这期特别采访有一个细节，关于这股剧的由来，这部剧诞生于导演一个朋友的硅谷岁月回忆，说道当时在硅谷工作的程序员同事，大多是极其聪明的人才，但在工作之外的大多领域却是完全不通世事。遂有此剧，既是为这一群人发声，也意为给大众带来生活的共鸣，谁也没想到最后火遍全球。 看小说的四天国庆前几天，倒是也没落下看书，断断续续看了十几个《羊脂球》的故事，看得也倒消遣，却始终没有感受到体内——对于阅读的一种热枕，不一多时，便想到可以靠一本金庸的小说来重燃阅读的习惯，正好当时又在豆瓣上看到《天龙八部》，一拍即合，即开始了四天的《天龙八部》生涯，意识又开始置身于瞬息万变的武林中。 总结普普通通的一周，自由，个人却不善安排，总是处于得好好想想才能有所安排的时间之中，（不太深刻地）感受到人性的枷锁，陷入青春绮丽的花园之中，却总是难以自我掌控，来回踱步而已。 想起前年国庆，就是在学校度过，而是看小说，当时看着《楚留香传奇》，小时候在家看楚留香传奇的记忆始终难以忘却，一股脑便看完了八部，愈写愈飘逸，后几部寥寥数笔便落幕，当时实在难以相信，但也意味深长。 国庆七天匆匆过去，匆匆到还没看完《天空八部》，近几天怕还是得花点时间了。就这样吧，周记写到这为止，此刻已经是10月8号，正坐在图书馆4楼，4096号，正好还是2的12次方。这是第一篇周记，希望周记、月记能尽量长久的坚持写下去，提升一下文笔，提升与自我交流的能力。","link":"/2019/10/08/个人/十月周记（国庆周）/"},{"title":"十月周记（第四周）","text":"日常周记 即便至今导师没有联系过给我安排任务，每周时间的流逝也总会给我紧迫甚至急促感，却并不充实。细细分析缘故，可能是因为每周大多都花在了一些繁琐的事情上，虽然都需要各方面的知识搜寻，但大多浅尝辄止，没有任何整体性了解和系统性学习的想法，只要搜搜博客，看看实例然后再改一改，任务结束便都抛在了大脑勺之后。 这周仍就格外匆忙，甚至给我一个预感，我的研一上学期会在这种状态下呼啸而过，不留痕迹。而我正置身于这篇泥沼之中，如果不尽力翻腾，或许没有任何悬念可言。 这周六的上机，着实不大容易，算法和开发，两块都是我的痛处，固然要好好在这方面努力，但时间似乎有不给准备的余地，唯有稳中前行吧，另外，实际一点吧，在学习上，勤而不辍。 这周先进软件开发技术课上，看到别人展示的内容，登时让我有些不知所措，一方面是对他们的向往，另一方面是对自己的幽怨。这种情绪平淡下来之后，我发现很多人（比如我经常）在看到别人光芒万丈（正是自己向成为的模样）时，往往第一感觉是自卑，其实并没必要。你还是你，并不会因为这番自卑而有所提升，或者打此以后便脱胎换骨，更应该庆幸能够看到这份差距，看到自己的向往变得具体化，是一件好事，可以给你前行的经验和途径。何况临渊羡鱼，不如退而结网。","link":"/2019/10/27/个人/十月周记（第四周）/"},{"title":"十月周记（第二周）","text":"十月第二周 两件事，两种际遇倏忽之间，到了13号，七天国庆似乎就在昨天，谁想到已经一个星期过去了，这一周似乎很充实，又似乎很缥缈。 细细回想起来，倒是有几件不小的事，这些不小的事情中，第一件当属0号上午收到的一封邮件了，导师通知联系实验室学长。随后，仅仅是吃过午饭之后，我便背上书包过去了，怀着各种期许，结果还算令人满意，就这样，我开始了实验室之旅。 第二件值得一提的事就是先进软件开发的大作业了，上个月选了个题目，任务是开发一个Android程序，与PC端配套的程序进行数据库和文件的指令操作。这件事跟这周本没有任何联系，直到老师课上说作业截止时间是下个月10号，我便忽尔开始意识到事情的急切。之所以急切，乃是我得从零开始学起安卓简单程序开发和socket通信，路漫漫其修远兮，尤其是三天过去后还没有跟着学完第一行代码的第二章内容。 这两起事放在一起，恰是因为这两件事对我的日常活动状况都有着切切实实的影响。 其它琐事似乎这周毫无趣事所言，至少是没有让我很是回味的趣事，这周好像跑到南二舍去了三次，渐渐日常化。说到去南二舍，立马想起周二从南二舍到图书馆的路上，碰到一张熟悉的面孔，随着自行车愈来愈近，就这样，加上了一个本科同学的微信。 这周六的补课（国庆节后的补课）课堂上，万老师很平淡地，一如既往地在不到二十分钟内写满了整个黑板，下课之际又平淡地宣布了矩阵论的结束，下周的数学就要从数值计算开始了，还是有些突然地，相对于的对矩阵论的准备程度而言。 某天晚上，从实验室回来，宿舍凳子还没坐热，便呼应了乒乓球群里的一个同学，居然也是自动化研一（和捷哥、博哥一样，和我不一样）学生，随后就在韵体打了半小时球。 最后值得提一笔的是这周开始看了一本书——此间的少年，江南的金庸小说同人作品，也是处女作，虽然前几年被金庸告了，内容值得一看，恰好是对他北大生活的一个回忆。 这周，还是没有为日常生活指定计划，还是长长心吧，答应自己，就从下周开始吧。","link":"/2019/10/13/个人/十月周记（第二周）/"},{"title":"十月月记","text":"这篇月记，主要是总结和规划 个人总结这个月似乎被大作业完全给占据了（也可能是个人以此为接口来摸鱼吧）。而且即便到月底还没没有把大作业给完整做出来。 总结起来这个月生活平淡中略有所惊喜吧，吃饭比较愉快，但是作业和篮球赛弄得比较蛋疼，很是繁琐，还是得学会适应这种繁琐的生活，合理安排精力和时间。 这个月很惭愧就看了三本书（天龙八部、此间的少年和长河），而且长河还有几篇没有看就匆匆还回了图书馆，不知道时间怎么就没了，希望以后能靠着这些文字记录，慢慢回忆起我的点点时光（不知道以后会不会看）。 中途几天降了温，没持续多久又想热天似的，只是把短裤T恤换成了长裤衬衣，另外更加注意了保湿。 比较积极的一方面是已经开始做每日计划了，用着数不清多久以前残留下的便利贴（也算是资源充分利用了），开始了每日计划，一般是前一天晚上或者当天早上写好要完成的几项任务。坚持了好几天了，虽然当下完成率不高，却感受到了在生活上付出努力程度的进步，可以作为个人能力阶段性养成计划的穿针之线。 个人规划学习重心编程语言上：Python &gt; Java &gt;JavaScipt &gt; others (此处不考虑SQL，毕竟和Git是俩是不可或缺的) Python方向上（按优先级排序）： 数据科学（含数理知识、机器学习、深度学习、数据挖掘与分析、部分分布式技术） 网络爬虫（计划就学完《Python3网络爬虫开发实战》) 图形界面设计，即学习PyQt 库的使用，并不打算很深入再了解尝试其它途径 框架学习，主要指Django ，有余力的情况下，学习并尝试一个完整的项目 大体上分为两方面了，软件开发与数据科学。 Java方向上： Java SE， 主要规划是学习梁勇的那套书、核心技术和Java虚拟机，外加百度云上一些文档资源 Java EE，当然就是对Spring 框架的探索了，不过深感精力有限，只能说在Python学习的基础之上吧 JavaScript目前准备就看完那本书，《JavaScript高级程序设计》，给自己一些前端知识脉络，有机会加上一些框架再配合Django 做一个完整的项目 其它体系知识补充主要就指：算法、设计模式、计算机原理等","link":"/2019/10/29/个人/十月月记/"},{"title":"此间的少年","text":"匆匆间，看完了这本书，此间的少年。 名字起得就很能引起共鸣，我们都是此间的少年，学校间、职场间、理想间和现实间。 这是江南第一本书，同人题材，借金庸武侠中的人物抒发对于大学生活的似水流年。至此，也开始了作家生涯，尔后的一切成就，都从这本书开始。这本书后来到有所际遇，16年因其人物名被金庸诉告。 大幕拉开内容从拉胡琴的莫大开始，一曲凤求凰，恍惚间便回到了笑傲江湖，在窗外的莫大，给令狐冲拉完一曲凤求凰便离去。 开始即高潮读到郭靖与黄蓉的故事，正好从新生报道开始，我有点投入进去了。看完之后最能在脑海中回忆的故事，也正是这一段，可能对许多人而言，刚到大学的那段时间恰是最美好的吧。两个人的相遇到相识可能满足了很多人的幻想。 逐渐日常化之后便是交织的几对人儿间的故事，内容也开始日常化，比较本来也是来源于大学日常。就像我们各自的大学生活，很日常，很欢乐，江南即是为自己而写，也是为我们而写，多少人曾想把自己的宿舍、校园生活记录下来却不曾落笔，看这本书期间，我也好好怀念了本科的四年光阴，我们都是此间的少年，聚在同一个小宿舍里，创造、分享各自的、共同的欢乐，然后任时光流转。 沉默中结束故事的最终，定格在各自的毕业，书的具体内容其实也没有太多值得回忆，乔峰、阿朱、康敏、杨康、穆念慈、段誉、王语嫣…都定格起来，对于我，其实更希望书中人物并不是同人名，但是这样可能也没有这个机会看这本书了，而且这样的题材，似乎即包含了大学生活的真实回忆，也保留住了大学时个人的一些生活狂想。有聚有散，离别总是让人深沉，我们每个人都不愿面对离别，也不擅长面对，所以我们各自沉默，一切想法都欲语未言，留在心底。 可能这就是青春独特的魅力吧，即使在多年之后，回忆起来仍然粲然心动，甚至动容落泪。附上以前摘录的一句话：流逝的日子像一片片凋零的树叶和花瓣。渐去渐远的是青春的纯情与浪漫。","link":"/2019/10/25/个人/此间的少年/"},{"title":"在细雨中呼喊","text":"读书笔记 在细雨中呼喊从这篇开始，慢慢建立起格式，暑假的时候本来准备按照“摘、评、批”的方式来读书，可是慢慢还是转向了电子化，现在的博客形式不大适合之前所想的批（当时计划的记录方式是按照时间轴记录各个主题的内容），准备使用“评、摘”的方式来写此后的读书笔记（现在的模式似乎不太像笔记）。 评论这本书看完有一段时间了，大概有半个月。这是我看的第二本余华小说，一如既往有着浓厚的乡土气息（这个词由于使用过于频繁以至开始有些变味），和之前看过的阎连科的我和父辈基调有相似之处。 可能出生在相同的大环境之下，书中很多情绪和场景都有所共鸣，好的坏的，不过我不够有敏锐的目光，不足以发现周末细枝末节的、荒诞的事，对此也值得庆幸，单纯是一件好事，就像照片的滤镜，让生活变得比实际中更美好。现实和想象也并没有高低之分，只要人快乐，活在那个之中都是可以的。 这本小说大致可以分为三个片段，家庭成长、上学时期和从上学拓展出来的故事。语言很有味道，还原了故事了画面甚至颜色，就是还原了很多人真实经历的生活，不带任何美化，有荒诞、离奇，比如父亲和哥哥在弟弟溺水而亡后的表现，村里寡妇的生活，当然也有美好的感动，就是生活的样子嘛，只不过我们大多不如作家敏感和细腻（也或者说是体验深刻），只能触摸到事情的表面。 虽然艺术来源于生活，但是各有特色，有的侧重记录或者构建美好，有的突出萧索和悲情，有的则没有明显的侧重地还原真实，宏观上来看处理都是相同的，对于真实的生活进行切片和快进、慢放调整，插入想象并进行时间轴的调整。如果硬是做这三个分类，那细雨中的呼喊明显是属于最后这类。 无关书籍的一些思考另外关于什么叫语言有味道，我现在觉得是语言的密度比较高，并且包含较为丰富的视觉内容。 关于语言的密度，我深深地记得微博上看过了一个研究结果，不同语言语义密度和语速的关系，是类似反比的关系，比较思维的速度大多是一致的（从群体整体来看），而多次的关注和考虑，加上看过的视频节目和文字内容，我认为中文是语义密度比较高的，抽象度要高一些，（也就导致，个人意见）准确度要低一些，比如相对于英语，可能这也是相互翻译比较考虑功底的原因，这是横向比较。纵向比较的话，由于个人经历深浅和多少的差别，加上触觉的不同（也可以算是体验或者感受的深浅差异），每个人言语表达内容的密度是不一样的，有的寥寥几句所能表达的就相当于其他人的长篇大论。 不过很多人故作文艺、深沉，说出的话、写出的文字看似如此，实际上空无一物。 另外关于语言传递的视觉内容，虽然语言是通过特定的人发出的，但是发出之后能传递的内容大多多于说话者的本意，一方面是人的误读，另一方面是不同经历的人能体会不同的画面（不太恰当的描述是：深者得其深，浅者得其浅。毕竟此处不侧重深浅、高低之较）。有味道的语言总是可以激发其很多不同的画面想象，可以说是因为部分读者想象能力比较丰富，但即便如此，能够勾起读者更多的想象空间也是一种能力。 摘录我们看到，在语言里现实和虚构难以分辨，而时间的距离则像目光一样简短，七年之间就如隔桌而坐。 我记得这样一个上午，一个清澈透明的上午，我跟在村里几个孩子后面奔跑，脚下是松软的泥土和迎风起舞的青草。阳光那时候似乎更像是温和的颜色涂抹在我们身上，而不是耀眼的光芒。 当他最后一次挣扎着露出水面时，他睁大眼睛直视了耀眼的太阳。 回想中的往事已被抽去了当初的情绪，只剩下了外壳。 我独自坐在池塘旁，在过去的时间里风程仆仆。 这无疑是属于美好的情景，多年后的记忆里重现时，竟然和暗示昔日屈辱的语文作业簿紧密相连。也许是记忆吧，记忆超越了尘世的恩怨之后，独自来到了。 这些日子来哥哥的举动让我感动，我一直想寻找一个机会向他表达自己的感激，可是笼罩着我们的沉默是我难以启齿。 长期以来，我固守着自己的想法。回首往事或者怀念故乡，其似乎只是在现实里不知所措以后的故作镇静。 迎着朝阳的光芒梳理头发，她的脖子微偏向左侧，初生的阳光在她光洁的脖子上流淌，沿着优美的身姿曲折而下。 她所紧紧抱住的是不属于她的东西，那具身体的离去迟早总会实现。现在我眺望往事时，仿佛看到她所抱住的不是一个人，而只是空气。 现在眼前经常会出现模糊的幻觉，我似乎能够看到时间的流动。时间呈现为透明的灰暗，所有一切都包孕在这隐藏的灰暗之中。我们并不是生活在土地上，事实上我们生活在时间里。田野、街道、河流、房屋是我们置身时间之中的伙伴。时间将我们推移向前或者向后，并且改变着我们的模样。 于是我找到了生与死之间的不同，活着的人是无法看清太阳的，只有临死之人的眼睛才能穿越光芒看清太阳。 我战栗地和他一起喊叫，一方面惊恐地感到罪恶正在来临，另一方面我又体验到无与伦比的激动和欢快。 音乐是从语言消失的地方开始的。 我不再装模作样地拥有很多朋友，而是回到了孤单之中，以真正的我开始了独自的生活。","link":"/2019/11/21/个人/在细雨中呼喊/"},{"title":"天龙八部","text":"《天龙八部》读书笔记经过旷日持久——长达五天的跨度，最终，在内心一阵愉悦和平和之下，看完了《天龙八部》，但是，拖了好几天才开始写这份读书笔记（但至少还是动笔键盘了）。 在金庸武侠世界遨游之际，总是会情不自禁想到古龙的几本书（主要是楚留香和小李飞刀），时长会边读边暗自比较，诚然古龙的小说会更飘逸和爽快，但金庸笔下的人物、事件构造似乎更具魅力和文学性。 这份读书笔记，真的仅笔记而已，并不会有太多个人感受和情绪抒发。 “天龙八部”从前看电视剧的时候，常会纳闷，到底天龙八部这个名字是什么意思，又或是究竟像表达什么。在这本三联版开篇前，有一篇金庸做的序，热心又详实介绍了书名的来历和含义，另外在序中，也看到了那句金庸小说的总结，当时很多出版武侠书籍上作者都是金庸，为了帮助读者进行正确分辨，金庸自己将小说名凑出了一副对联：飞雪连天射白鹿，笑书神侠倚碧鸳；序中同时还表达了自己历史观的进步，初时写作时，持有强烈的汉人皇朝正统观念，后期则以将中华民族各族一视同仁的基调进行小说创造。 “天龙八部”出自佛经，许多大乘佛经都有所提及，金庸给了《法华经·提婆达多品》的例子：“天龙八部、人与非人,皆遥见彼龙女成佛”。“天龙八部”实指八类生灵，是“非人”，一共八者，何以“天龙”为首？乃因此八类生灵中以“天”、“龙”为首。八部者，一天、二龙、三夜叉、四乾达婆、五阿修罗、六迦楼罗、七紧那罗、八摩呼罗迦。 故事的发生故事发生与北宋哲宗哲宗元祐、绍圣年间,公元1094年前后，以云南大理起笔，多个故事间起承转合，浑然一体，主人公从段誉到萧峰，再过渡到虚竹。 故事起源于雁门关一战，大燕皇室后裔慕容博，为引起宋、辽间的矛盾，谎称有一行大辽高手将潜入少林寺盗少林武功秘籍，这一行人将经过雁门关，于是以之后的少林方丈玄慈为首的武林高手，一行十多人，便前往雁门关伏击。 此行却误将普通的辽国士兵杀害，而适逢萧远山带着妻儿走完丈老回来，于是双方迎面冲撞起来，萧远山妻子被杀，而受师于中原人士，发誓不杀宋人的萧远山杀了十位中原高手后，在一块石头上写下事情的经过便跳崖自尽，跳下之际将怀里的婴儿抛了上去，抛到丐帮帮主白世镜手上。而后幸存的一行人拓下石头上的文字，找人弄明白后懊悔起来，便决定将婴儿萧峰抚养成一位堂堂正正的大丈夫，掉落山崖的萧远山命不该绝，挂在一棵树上，也再无自杀之意，内心燃起复仇之意。 此后萧远山得知当日一行人意图后，便一不做二不休，干脆潜入少林寺，决心看尽少林武功秘籍，并规划着复仇之行。始作俑者慕容博为辞其咎，便在假死候亦潜入少林寺，学其典籍，以为大燕复兴而练功。就这样，两个人在少林寺潜伏了长达二十年，二十年间，各自在功力上也是大有所获，多次交手却始终难分胜负，这一切却都看在少林寺一位默默无闻的扫地僧眼中。 逍遥派同门三位弟子的爱恨情仇，无涯子、李秋水、天山童姥，三者同为逍遥子弟子，各自功力都是深不可测，有小无相功、北冥神功、天山折梅手、凌波微步等世间绝学。无涯子与李秋水在大理秋水在大理国无量山琅嬛福地隐居过一段时间，育有一女李青萝，而后无涯迷恋上了自己亲手雕成的玉像（玉像之人为李秋水妹妹，与李秋水较为相似） 大理情圣段正淳，大理皇室，大理皇帝之弟，位居王爷，武功较为高超，风情种，在四处周游途中四处生情。先后与6位女子发生感情，共有5女，囿于皇室地位，只和刀白凤结为夫妻。另外五名女子是： 秦红棉，有女木婉清(这个名字实在好听，水木清华，婉兮清扬) 甘宝宝，有女钟灵 王青萝，有女王语嫣 阮星竹，有女阿朱、阿紫，可惜命运不佳 康敏，后为丐帮副帮主之妻，时称马夫人，卖弄姿色，心狠手辣 也是造化弄人，和自己妻子刀白凤却无子无女，段誉乃刀白凤与段延庆所生（为报复段正淳拈花惹草），天龙寺外，菩提树下，叫花邋遢，观音长发。可惜段正淳至死也未知。 几大“反派”经典形象，四大恶人： 恶贯满盈 段延庆 无恶不作 叶二娘，与少林方丈玄慈生下虚竹，萧远山盗走虚竹后备受刺激，走上歧途 凶神恶煞 南海鳄神，向收段誉为弟子却反成其弟子，多次出场，比较滑稽 穷凶极恶 云中鹤 星宿派创始人 星宿老怪 丁春秋萧峰之后的丐帮帮主 庄聚贤 游坦之 一代新人换旧人大理公子段誉，饱读经书却全无武力，在外闯荡邂逅钟灵、木婉清。无意间误入琅嬛福地，学到凌波微步和悲悯神功，而后在长辈天龙众僧对抗鸠摩智之际学到绝学六脉神剑，奈何过于优柔，总是不尽人意。 在天龙寺对战中被鸠摩智所擒，尔后来到江南慕容家，同时邂逅一生之迷王语嫣，最后终与王语嫣心意合一（三联版，新修版王语嫣最后跟慕容复成了眷属），同时也碰上阿朱、阿碧俩古灵精怪的姑娘。 而后马大元之死牵扯出二十年前血案，丐帮帮主乔峰追清身世，辞去丐帮帮主之位，并与段誉义结金兰。 虚竹后续登场，揭开逍遥派故事，与西夏公主“梦姑”的感情线也不能说不是一大好安排。 全篇最为主要的矛盾冲突发生在少室山，来了一场武林大起底，可谓是名场面了。之后段家情长也较为吸睛。 最后，伴随着萧峰之死，大辽退军，江湖又渐渐归为平静，一个个故事也从始到末，化为无声。 写在最后一首诗，一句话，诗与本本书并不太相关，乃射雕中提及，却在读完本书之际意外地印象深刻。话则是陈世现骧对天龙八部全文评语。 《题临安邸》 宋 林升山外青山楼外楼，西湖歌舞几时休？暖风薰得游人醉，直把杭州作汴州。 无人不冤，有情皆孽","link":"/2019/10/11/个人/天龙八部/"},{"title":"第一篇博客","text":"喜提博客 经常下午和晚上的摸索，终于搭建起自己的博客，或者说是个人网站，来之不易，希望好好坚持下去！","link":"/2019/09/27/个人/第一篇博客/"},{"title":"羊脂球","text":"《羊脂球》读完之后的一些回忆 读书总结断断续续花了大概三周的时间，看了《羊脂球》这本书，没说看完了，是因为后面跳过了大概六七篇的样子。 似乎开始于上个月的某个深夜，我打开了这本书，一如预期地发现是一本短篇故事集子。记得以上上课学过的莫泊桑的项链和我的叔叔于勒，翻看目录，都在其中。 书中大部分内容都算是针砭社会了，集中在对一群群上层和中产分子的讽刺，对人人性的揭露，给我们呈现了一幅当时社会的部分风貌（或许是一大部分）。书中很多故事都发人深省，对人性表现得比较透彻。当时的法国和我们现在，或者说起前几年社会富起来的时候是一致的，虚荣、虚伪、冷漠充斥着社会。 印象比较深的有三篇内容，第一篇就是羊脂球了。看开书之前一直不明了书名的羊脂球的含义，看之后发现居然是“人名”（或者说是绰号），用以描述一个妓女的体型。故事就不多描述了，反应的主要还是人的自私、冷漠，羊脂球把食物给了车上每一个人，最终得到的确是众人希望她满足军官的欲望，以换取众人的通行，期间虽然一位先生报了过一段时间气节，认为不能像德国军官屈服，不可牺牲羊脂球，最后却也和其他人一般，甚至主动劝说羊脂球。在通行之后，羊脂球被所有人所漠视，想躲避传染病似的避开她。 第二篇名叫瞎子，一个天生残疾的瞎子，并不因为残疾而受到关怀，反而是受到各种歧视和欺辱，被村里人欺负，被家人逼迫讨饭，最后在一个下雪天里离开了人世，尸体被乌鸦啄食。其实现在这种事情何尝又没有发生，校园暴力、社会暴力，很多时候弱者不仅得不到社会的关爱，反而成为耍弄、发气的对象，中学期间见过活生生的例子。希望尽量让自己成为一个温暖的人，社会想必也会温暖上许多。 第三篇篇名已经忘记，只记得大致内容，讲的是法国社会当时有一段时间，大量的狗被扔到坑洞里面活埋，原因就是当时养狗国家收取额外的费用，而对于许多小说中吝啬的主人公们，这当然是不可忍受的，尽管也有着同情、怜悯之心，但这些怜悯心在金钱面前一一粉碎，养狗只是维持或提高自己在社会中的形象，都是面子上的事情。 摘录：他们结婚以后生了两个孩子，原来就感到的拮据变成了那种自惭形秽、掩掩藏藏、羞于让人知道的贫困，仍然想保住自己的身份地位的贵族家庭的那种贫困。 就像所有哪些没有及早对严峻的生活斗争做好准备的人，就像所有那些隔着一层云雾观看人生，不会耍手段，不善于斗争，从小就没有被人培养出一些特殊的本领，一些独特的才干，一种充沛的斗争毅力的人，就像所有那些没有人把一件武器或者一件工具交到他们手上的人，他在这块暗礁上搁了浅。 如果她没有遗失那串项链，会是怎么一个情况呢？谁知道呢？谁知道呢？人生朵儿离奇古怪，多么变化无常！只需一点点小事情就可能把您毁掉或者使您得救！ “有什么关系，只要她幸福”","link":"/2019/11/14/个人/羊脂球/"},{"title":"Git笔记","text":"Git学习笔记 本地仓库常用操作初始化全局信息1234git config --global user.name \"username\" # 更改用户名 或 设置用户名git config --global user.email \"emailaddress\" # 更改用户邮件地址 或 设置用户邮件地址git config user.name # 查看用户名git config user.email # 查看用户邮件地址 创建版本库版本库：保存某群文件历史记录的仓库，可以利用版本库将文件恢复到任意想恢复的历史版本。版本库实际上是一个隐藏文件夹，文件夹名为.git 进入想创建版本库的文件夹，打开该文件夹目录 1git init 或者想在某处直接创建一个文件夹并建立版本库 1234mkdir xx(文件夹名，精良用英文)cd xxpwdgit init 添加文件到Git版本库12git add readme.txt # or some file name else，只是将本文存在stage(暂存区)git commit -m \"append a readme file\" # 将文件提交至版本库，后面的字符串为提交信息 查看版本中的状况并比较差别12git statusgit diff readme.txt # 可返回版本库中与目前文件夹内readme.txt文件的差别 版本回退1234567git log # 查看版本记录git log --pretty=oneline# 相对版本回退git reset --hard HEAD^ # HEAD后跟上几个^就是向前回退多少个版本（相对次数回退），如果次数比较大，比如向前回退100个版本，写HEAD~100# 绝对版本回退git reset --hard 07e0 # 根据git log显示的版本记录，每个记录有一个哈希数字，找到对应版本哈希数字的前x位，用在此处，如07e0git reflog # 这个指令记录了每一次版本相关的操作 工作区与暂存区 工作区（Working Directory）：.git所在的目录下，除了.git之外的其他文件都是在工作区内 版本库（Repository）：.git目录内所存的记录，有暂存区和Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 stage（或者叫index）的暂存区：用add命令放进来文件的位置 经过add添加的文件只会添加到stage，需要再次操作（commit，即提交）才能放到版本库，相当于需要二次确认操作才能完成版本添加。 123git diff # 如果不加参数则默认比较工作区与暂存区git diff --cached [&lt;path&gt;...] # 比较暂存区与最新版本库git diff HEAD [&lt;path&gt;...] # 比较工作区和最新版本库 撤销修改对于存到暂存区的文件，如果不想提交到版本库，可以尝试撤销。或者工作区的文件修改后，希望撤销该修改。 12git checkout -- test.txt # --不能省略，后面后加具体文件或者正则式匹配，作用是撤销工作区文件修改git reset HEAD # 对于已经存到暂存区的文件，根据git status的提示进行撤销 对于已经存在版本库的版本文件，可以利用版本回退进行处理。 文件删除文件删除命令同Linux下操作（毕竟Linux内核和Git都是一个人做出来的） 1rm readme.md 远程仓库常用操作首先是本地SSH的创建和与远程仓库（如GitHub、阿里Code等）账号的SSH绑定（具体百度） 连接远程仓库在远程创建一个空仓库（不含readme文件）后，通过以下指令进行连接 1git remote add origin xxxx # 后面的xxxx为具体网址，http或者ssh，origin为在本地自定义的仓库名 下载或拉取远程仓库文件如果远程仓库已经有文件，则只能先下载下来，或者拉取下来 12git clone xxxxgit pull origin master # 如果报错可以在后面加上参数--allow-unrelated-histories 将本地文件推送到远程1git push -u origin master # -u是指定后面的的仓库名和分支名为默认，之后便可直接用git push 与远程仓库解除绑定1git remote remove origin 修改绑定的远程库 1git remote set-url origin xxxx 分支管理12345git branch # 查看分支，显示结果中前面标有*号的是目前所处分支git -b checkout dev # 增加并切换到名为dev的分支git merge dev # 合并dev分支到目前所处的分支（若出现冲突需要先根据提示进行修改）git branch -d dev # 删除dev分支git log --graph --pretty=oneline --abbrev-commit # 图形化分支显示","link":"/2019/11/15/各类技术/Git笔记/"},{"title":"Markdown写LaTeX","text":"此篇博客记录下关于$LaTeX$的基本数学符号输入语法（仅抽取出关于数学公式的输入语法），也是顺便熟练一下。 由于现在开始在博客上写一些数学笔记，很重要而繁琐的一件事就是输入数学公式，我的笔记都是通过Typora书写，然后利用python脚本打上一个文件头标签后放到HEXO博客上，Typora是内置$LaTeX$支持的，而根据网上的经验，已经调整好HEXO对$LaTeX$的支持。 基本知识markdown所支持$LaTeX$公式输入分为两种： 行内公式 ，利用两个$ 进行包裹 行间公式，利用两个$$$$进行包裹 关于上小标： 上角标^ 小角标_ 式子中空格和分行都会被忽略掉，但是可以利用特殊语法进行输入 \\,,\\quad,\\qquad ，效果分别如右：$a\\,a$,$a\\quad a$,$a\\qquad a$ 在公式后输入普通文本（比如中文、空格、分行）：\\textrm{...}， \\\\为分行 基本数学符号对于集合（如实数集），有两种方式，实心和空心，分别为\\mathbb{...},\\mathbf{...}，效果：$\\mathbf{R}$,$\\mathbb{R}$ 各类括号，包括四个层级\\big,\\Big,\\bigg,\\Bigg，用在标准括号前面，可调整实际的显示大小。 基本运算符 运算符 语法 $\\times $ \\times $\\div $ \\div $\\setminus $ \\setminus $\\star $ \\star $\\ast $ \\ast $\\equiv $ \\equiv $\\leq $ \\leq $\\geq $ \\geq $\\ll $ \\ll $\\gg $ \\gg $\\neq $ \\neq $\\frac{1}{n} $ \\frac{}{} $\\sqrt[5]{5}$ \\sqrt[]{} $\\lim $ \\lim $\\int $ \\int $\\oint $ \\oint $\\sum $ \\sum $\\prod $ \\prod 衔接符号 含义 语法 效果 字母上加横线 \\overline{} $\\overline{X} $ 字母下加横线 \\underline{} $\\underline{X} $ 向量 \\vec $\\vec X$ 方向向量 \\overrightarrow{} $\\overrightarrow{AB}$ 字母上加^ \\hat{},\\widehat{} $\\hat{x},\\widehat{X}$ 字母上加波浪线 \\tilde{},\\widetilde{} $\\tilde{x},\\widetilde{X}$ 右箭头 \\rightarrow $\\rightarrow$ 左箭头 \\leftarrow $\\leftarrow$ 单圆点 \\cdot $\\cdot$ 三个圆点(基线) \\ldots $\\ldots $ 三个圆点(居中) \\cdots $\\cdots $ 三个圆点(垂直) \\vdots $\\vdots $ 三个圆点(对角) \\ddots $\\ddots$ 波浪线 \\sim $\\sim $ 希腊字母 小写希腊字母 语法 $\\alpha $ \\alpha $\\beta $ \\beta $\\gamma $ \\gamma $\\delta $ \\delta $\\epsilon $ \\epsilon $\\varepsilon $ \\varepsilon $\\zeta $ \\zeta $\\xi $ \\xi $\\eta $ \\eta $\\theta $ \\theta $\\vartheta $ \\vartheta $\\lambda $ \\lambda $\\mu $ \\mu $\\nu $ \\nu $\\kappa $ \\kappa $o $ o $\\pi $ \\pi $\\rho$ \\rho $\\sigma $ \\sigma $\\upsilon $ \\upsilon $\\phi $ \\phi $\\varphi $ \\varphi $\\chi $ \\chi $\\psi $ \\psi $\\omega $ \\omega $\\tau $ \\tau 大写希腊字母 语法 $\\Gamma $ \\Gamma $\\Delta $ \\Delta $\\Theta $ \\Theta $\\Lambda $ \\Lambda $\\Xi $ \\Xo $\\Pi $ \\Pi $\\Sigma $ \\Sigma $\\Upsilon $ \\Upsilon $\\Phi $ \\Phi $\\Psi $ \\Psi $\\Omega $ \\Omega","link":"/2019/12/01/各类技术/Markdown写LaTeX/"},{"title":"PyQt开发基本框架及线程","text":"简要介绍PyQt基本实现框架，和线程设计的一些问题 在利用PyQt做界面设计过程中，发现并不是将原有代码随意往GUI功能块上进行简单的拼凑，不然也太过于简单了，虽然大多优秀的工程都是优美、简洁的，其背后的付出和设计却大相径庭，往往是十分繁琐、耗时，需要大量精力投入、精密计算和创造性设计的。（题外话） 虽然这些内容其它博客大多有，但却并不是我的思维，不是我的尝试和学习过程，自己总结出的经验才是适合自己的，能让我在之后忘记这一切的当头通过这些文字快速串联起来。 基本框架（基于将设计文件已转换为了Python文件，忽略大多需要引用的类） 自动转化而成的Python设计文件，其内容就是一个类，其中有两个方法：setupUi、 retranslateUI 为了整个项目的模块化和后期阅读、更改、维护，尽量新建文件放置功能模块代码。以下基本框架介绍按照运行的递归顺序。 界面运行123456if __name__ == '__main__': app = QApplication(sys.argv) my = MyMainWindow() my.show() sys.exit(app.exec_()) 这处为界面运行的引导代码，第一句和第四句一般是固定的（QApplication为从PyQt中引入的模块），二三句则是自行调整，此处我们的窗体类名为MyMainWindow，实例化对象命名为my，通过方法show进行循环运行。 若设计多个界面跳转，可建立多个窗体类和实例化对象，通过事件（通常即按钮）来进行跳转响应。 窗体类窗体类中，主要用于功能与界面设计中模块的绑定（如按钮、输入输出文本框等等） PyQt中常用的模块主要有：Push Button、Label、Text Browser、Line Edit、Text Edit。 在初始化方法里，进行按钮绑定（主要是按钮） 12345678910111213class MyMainWindow(QMainWindow, main_ui.Ui_MainWindow): def __init__(self, parent=None): # 初始化 super(MyMainWindow, self).__init__(parent) self.setupUi(self) self.ip = self.host_ip() self.listen_thread = None # 按钮功能绑定 self.get_ip_button.clicked.connect(self.set_ip) self.listen_button.clicked.connect(self.start_listen) self.stop_button.clicked.connect(self.stop_connection) self.exit_button.clicked.connect(self.close) 窗体类为多继承结构（此处继承了两个类，第一处继承是PyQt的主窗体类，第二处为我们的界面设计类），通过调用setupUi来引入设计中的各模块，下面四句则是按钮绑定，具体方法为按钮.clicked.connect(响应函数) 各种文本框的内容设计，一般放在窗体类的其它方法中，通过键盘输入、按钮或者线程活动进行内容变更。 窗体的主要功能应该都放在窗体类中。 线程设计大多项目开发中，都绕不开线程的设计，PyQt中，有单独的线程类QThread， 当然也可以使用Python中的线程类，QThread无疑是由Python中的基本线程改造而得，相必必有其优势，比如更好的配合PyQt的信号和槽机制。 信号和槽机制：简要介绍，就是在线程设计中，由于线程为单独的类，如何与窗体类进行信号交互呢，就是通过该机制，在线程类信号，窗体类中为槽，信息通过信号发射到槽内。 线程与槽的具体实现： 在线程类中设立传递信号的变量：如msg = QtCore.pyqtSignal(str)，msg即为该变量，看其它博客的案例，通常都是作为类变量，str表明传递的是字符串信息，也可以传递其它内容，比如我在开发中设计了一个传递自己定义的某类对象的信号变量 传递信息：self.msg.emit(传递信息内容) 接受信息：在窗体类中，建立起线程后，可将文本框（或其它能接受信息的对象、变量或方法作为槽）作为槽，此处为TextBrowser对象，简单绑定即可，self.listen_thread.msg.connect(self.textBrowser.append)。此处，线程类名为listen_thread，括号内不是变量而是方法，（注：槽应该是方法名而不是变量，不加括号），最为关键的是connect这一方法，起着连接作用。 线程创建和实例化：创建线程必须继承自QThread类（或使用Python线程），可根据需求进行类变量设计和初始化方法的设计，主要功能代码放在run方法中，run方法是对QThread内方法的重载。 实例化方法（此处线程名为ListenThread）： 12listen_thread = ListenThread()listen_thread.start() 要顺利完成线程的使用，需着重注意的一个问题：线程中重载的方法是run，实例化线程运行的方法是start。","link":"/2019/11/04/各类技术/PyQt开发基本框架及线程/"},{"title":"利用PyQt写GUI的基本流程","text":"大作业途中的一个收获 近期的大作业和上机题，都是关于socket和界面设计的，由于几门语言中Python掌握的算可以一些，遂都选用Python来进行设计。对于界面开发，一番查询得知PyQt这一强大工具，便了解了一小段时间。 介绍PyQt: Python的一个第三方库，可以进行GUI的开发工作，是Qt库（似乎是最强的GUI库了，不过服务于C++的，官方定位是Ｃ++ Framework）的Python实现（似乎不是Qt官方出品） 借助PyQt强大的Qt库，再结合Python简练的语法，可以在短时间内做出功能完善的桌面端软件。 基本流程（不涉及编程细节） 借助Qt Designer，利用拖拉拽的方式，设计出软件的界面，保存设计可生成ui文件 利用PyUIC，可以将ui文件转为Python文件 利用Python和PyQt语法（可能再结合其它库）进行编程，写出完备的代码 利用pyinstaller，可将Python代码封装成可执行程序（Ubuntu或Windows软件都可生成），自此，完成了整个流程 其中PyUIC、Qt Designer都是随Anaconda装上的（Anaconda真是方便），pyinstaller自行pip安装一下即可，在Pycharm里可将PyUIC、Qt Designer都导进外部工具中，具体细节可自行看看CSDN上的博客。","link":"/2019/10/30/各类技术/利用PyQt写GUI的基本流程/"},{"title":"一元线性回归","text":"一元线性回归理论与实践 理论回归问题，最简单也是最为普遍的就是线性回归问题，而一元线性回归（或简单线性回归）可是一块敲门砖。 模型一元线性回归，包括两类数据：数学上通常命名为自变量（$X$）与因变量（$Y$），两者一一对应。样本如下： X:x_1,x_2,\\cdots ,x_n$$；$$Y:y_1,y_2,\\cdots,y_n该理论认为两者具有以下关系： Y=aX + b + \\epsilon即两者称线性关系，式中$\\epsilon $为引入的随机误差（或随机扰动），通常为服从$N(0,\\sigma^2 )$的正态项。可这样认为：有一个一元线性系统（模型），样本数据都是由该系统生成，由于系统一定程度的随机性，数据在整体服从一元线性关系的基础上会有着一定程度的数值偏离。 问题按照前面提及的思想，数据为一个一元线性系统生成，按照上述公式模型，那么对于一组给定的样本数据，我们要做的就是通过该组数据复现出（具体化）模型（即求出参数$a,b$），然后便可根据该模型来支持我们的分析工作和预测工作。 参数求解的简要思路对该问题，实际上有着数学和计算机科学的两种解决思路，前者着重于纯粹的数学理论，后者在一定的数学理论基础上，辅以计算机优势（重复迭代计算）。两思路可进一步归类于统计方法和机器学习。 统计方法由于$\\epsilon$为正态项，那么可以把$y_i$看作是$a,b,x_i,\\sigma $已知下的变量，服从正态分布$N(aX+b,\\sigma^2)$，采用参数估计中的最大似然估计。似然函数如下： P(Y|a,b,X,\\sigma^2)=\\prod P(y_i|a,b,x_i,\\sigma^2)\\ln (P(Y|a,b,X)) = -0.5n\\ln (2\\pi \\sigma ^2)-(\\frac{1}{2\\sigma ^2})\\sum _i(y_i-ax_i -b)^2采用最大似然估计，参数$(a,b)$的估计量值为$(\\hat{a},\\hat{b})$，则有： (\\hat{a},\\hat{b})=\\arg\\min_{a,b}P(Y|a,b,X,\\sigma ^2) = \\arg\\max_{a,b}\\sum_i(y_i-ax_i-b)^2利用微积分求极值思路可求出估计量$(\\hat{a},\\hat{b})$ 机器学习首先定义损失函数$J(a,b)=\\frac{1}{2n}\\sum_{i=1}^n(ax_i+b-y_i)$，然后通过梯度下降对其进行迭代参数更新，直至参数收敛。 实践 步骤： 数据预处理 调用模型 预测结果 可视化 数据集(学习时间、学习成绩)： X:(2.5, 5.1, 3.2, 8.5, 3.5, 1.5, 9.2, 5.5, 8.3, 2.7, 7.7, \\\\ 5.9, 4.5, 3.3, 1.1, 8.9, 2.5, 1.9, 6.1, 7.4, 2.7, 4.8, 3.8,\\\\ 6.9, 7.8, 2.1, 2.2, 2.5)Y:(21, 47, 27, 75, 30, 20, 88, 60, 81, 25, 85, 62, 41, 42,\\\\ 17, 95, 30, 24, 67, 69, 30, 54, 35, 76, 86, 93, 93, 93) 数据预处理此处仅需两个步骤：数据读取和数据集拆分 12345678910import pandas as pdimport numpy as npimport matplotlib.pyplot as pltdataset = pd.read_csv('studentscores.csv')X = dataset.iloc[ : , : 1 ].valuesY = dataset.iloc[ : , 1 ].valuesfrom sklearn.model_selection import train_test_splitX_train, X_test, Y_train, Y_test = train_test_split( X, Y, test_size = 0.25, random_state = 0) 调用模型12345678from sklearn.linear_model import LinearRegressionmodel = LinearRegression()model.fit(X_train.reshape(-1,1) , Y_train) # 接收的X需为二维，因为LinearRegression并不只针对一元线性回归'''model.coef_:自变量和因变量的相关系数（回归系数），即一元函数y=ax+b中的amodel.intercept_:截距，b''' 预测结果12Y_pre = model.predict(X_test.reshape(-1,1))score = model.score(Y_test, Y_pre) model.score用于衡量模型的预测效果，定义如下 R^2 = 1-\\Big(\\frac{u}{v}\\Big)其中，$u$是预测值和真实值的残差和（系统误差和随机误差），$v$是真实值和真实值平均数的残差和（随机误差） 可视化12345678训练集plt.scatter(X_train, Y_train, color='red')plt.plot(X_train, model.predict(X_train.reshape(-1,1)), color='blue')plt.show()测试集plt.scatter(X_test , Y_test, color = 'red')plt.plot(X_test , Y_pre, color ='blue')plt.show()","link":"/2019/12/02/数据科学/一元线性回归/"},{"title":"HTML笔记","text":"HTML基础知识点，看视频时做的一些笔记 HTML文件又若干标签和文本、链接构成，标签为&lt;xx&gt;形式，标签内开头单词标识标签的功能，后面可以跟若干参数，参数值得设置为&quot;xx&quot;，由一对双引号包围。 基本框架12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;标题&lt;/title&gt; &lt;metaset charset=\"utf-8\"&gt;&lt;/metaset&gt; &lt;/head&gt; &lt;body&gt; 网页显示内容 &lt;/body&gt;&lt;/html&gt; 一个HTML文件主要有两部分构成：head,body，前者是头文件，存放一些网页设置内容，如metaset charset=&quot;utf-8&quot;指定了网页的编码格式，否则无法正常显示中文；后者是内容文件，保存的网页中要显示的所有内容。 以下内容着重于body中的语法规范。 文本显示12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;h1 align=\"center\"&gt;标题1&lt;/h1&gt; &lt;!--块级标签，一共有1-6六种标签，align设置排列模 式:center,left,right --&gt;&lt;hr width=\"20%\" size=\"20px\" color=\"red\"/&gt; &lt;!-- hr为水平线标签 width设置水平线长度，百分比和绝对像素:20%,200px align size设置高度 color设置颜色 --&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;段落一&lt;/p&gt; &lt;!-- 段落标签，将数据作为整体显示，方便j&amp;，css设置，会自动换行且具有一定的段间距 &amp;nbsp;空格 （权重标签，可嵌套使用） b:加黑 i:斜体 u:下划线 del:中划线 --&gt;&lt;ul&gt; &lt;li&gt;北京&lt;/li&gt; &lt;li&gt;上海&lt;/li&gt; &lt;li&gt;杭州&lt;/li&gt; &lt;li&gt;成都&lt;/li&gt; &lt;li&gt;深圳&lt;/li&gt;&lt;/ul&gt;&lt;ol&gt; &lt;li&gt;张&lt;/li&gt; &lt;li&gt;郑&lt;/li&gt; &lt;li&gt;万&lt;/li&gt;&lt;/ol&gt;&lt;dl&gt; &lt;dt&gt;Tech:&lt;/dt&gt; &lt;dd&gt;Python&lt;/dd&gt; &lt;dd&gt;JavaScript&lt;/dd&gt; &lt;dd&gt;Django&lt;/dd&gt; &lt;dd&gt;Machine Learning&lt;/dd&gt;&lt;/dl&gt; &lt;!-- ol:有序列表标签 ul:无序列表标签 li:单个列表元素 type:1,a,A,I ol标签的序号,上述三者分被为阿拉伯数字、小写字母、大写字母、罗马数字 dl:自定义列表标签 dt字段为标题 dd字段为列表元素 --&gt;&lt;img src=\"../img/pikachu.jpg\" title=\"pikachu\" height=\"200px\" /&gt;&lt;br&gt; &lt;!-- img:图片标签 src:路径 width:（像素块大小或者百分比） height:（像素块大小或者百分比） title:图片标题，鼠标触到时显示 alt:当图片显示不成功时加载的文字信息 --&gt;&lt;a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;img src=\"../img/baidu.gif\" title=\"百度一下\" width=\"100px\"/&gt;&lt;/a&gt; &lt;!-- a:超链接标签 href:要跳转的网页资源路径 target:指定要跳转的网页资源的显示位置， _blank:在新标签中打开 _self:在当前页中刷新显示 _top:在顶层页面显示 _parent:在父级层次页面显示 --&gt; 单元格及合并123456789101112131415161718192021222324252627表格标签 &lt;!-- 表格标签学习： tabel:声明一个表格 tr:声明一行 td:声明一个单元格 th:声明一个表头单元格，默认加黑居中显示 属性： border:边框 width: height: cellpadding:设置内容距离边框的距离 cellspacing:设置边框的大小 --&gt;合并 &lt;!-- colspan:设置占据行单元格的数量 rowspan:设置占据列单元格的数量 第一步： 确保表格是一个规整的表格 第二步： 根据要合并的单元格，找到其所在的源码位置 第三步： 行合并：在要合并的单元格中的第一个单元格上使用属性rowspan=\"个数\"，并删除多余的单元格 列合并：在要合并的单元格中额任意一个上使用属性colspan=\"个数\"，并删除多余的单元格 --&gt; 内嵌标签123456789101112&lt;iframe src=\"http://www.baidu.com\" width=\"80%\" height=\"500px\"&gt;&lt;/iframe&gt;&lt;iframe src=\"http://www.taobao.com\" width=\"48%\" height=\"500px\"&gt;&lt;/iframe&gt;&lt;iframe src=\"\" width=\"48%\" height=\"500px\" name=\"_if\"&gt;&lt;/iframe&gt;&lt;a href=\"http:www.jd.com\" target=\"_if\"&gt;京东&lt;/a&gt; &lt;!-- iframe:内嵌标签,网页嵌入，比如图片、视频、音乐... src:资源,可以是本地资源，也可以是网络资源 注意：默认当前页面打开及加载src的指向资源 width,height:尺寸设置 也可不设置src，而通过name引用标签a的href资源 name:设置内嵌区域的名字，结合超链接标签的target属性使用 --&gt; 超文本显示链接：&lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt;;其中target=&quot;_blank&quot;表示从新页面打开此链接，否则从当前页面打开。 图片：&lt;img src=&quot;../img/baidu.gif&quot; width=&quot;100px&quot;&gt; 框架标签HTML中有一一类框架标签&lt;frameset&gt;，通过对页面的切分，进行框架设置、页面嵌入等操作。有一大注意要点：&lt;frameset&gt;与&lt;body&gt;标签不能共存，只能二选一。 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;框架标签&lt;/title&gt; &lt;metaset charset=\"utf-8\"&gt;&lt;/metaset&gt; &lt;/head&gt; &lt;frameset rows=\"10%, *, 10%\"&gt; &lt;frame src=\"top.html\" /&gt; &lt;frameset cols=\"10%, *\"&gt; &lt;frame src=\"left.html\" /&gt; &lt;frame src=\"right.html\" /&gt; &lt;/frameset&gt; &lt;frame src=\"bottom.html\" /&gt; &lt;/frameset&gt; &lt;!-- 具有布局的更高灵活性 注意： 要删除body标签，frameset不可与body标签共存 rows:按照行进行切分页面 cols:按照列进行切分页面 子标签: frame:进行切分区域的占位，一个frame可单独加载网页资源 src:资源路径（本地或者网络） name:区域名，结合超链接使用 --&gt;&lt;/html&gt; 表单12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;form action=\"#\" method=\"get\"&gt; 用户名：&lt;input type=\"text\" name=\"uname\"&gt;&lt;br&gt; 密码：&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;input type=\"text\" name=\"upwd\"&gt;&lt;br&gt; 性别：男&lt;input type=\"radio\" name=\"sex\" value=\"1\"&gt;女&lt;input type=\"radio\" name=\"sex\" value=\"0\"&gt; &lt;br&gt;爱好：&lt;br&gt;吃饭&lt;input type=\"checkbox\" name=\"fav\" value=1&gt; &lt;br&gt;看书&lt;input type=\"checkbox\" name=\"fav\" value=2&gt; &lt;br&gt;打游戏&lt;input type=\"checkbox\" name=\"fav\" value=3&gt; &lt;br&gt; 爱好城市:&lt;br&gt; &lt;select name=\"fav_city\"&gt; &lt;option value=\"\"&gt;--请选择--&lt;/option&gt; &lt;option value=\"1\"&gt;成都&lt;/option&gt; &lt;option value=\"2\"&gt;杭州&lt;/option&gt; &lt;option value=\"3\"&gt;深圳&lt;/option&gt; &lt;/select&gt; &lt;br&gt; 个人介绍： &lt;br&gt; &lt;textarea name=\"intro\" cols=\"10\" rows=\"10\"&gt; &lt;/textarea&gt; &lt;br&gt;&lt;input type=\"submit\" value=\"登录\"&gt;&lt;/form&gt;&lt;!-- form表单标签学习: 作用:收集并提交用户数据给指定服务器 注意:form标签会收集其标签内部的数据 属性: action:收集的数据提交地址，也就是URL method:收集的数据的提交方式，分为get和post两种 get:适合小量数据，表单数据以？隔开拼接在URL后面， post:适合大量数据，安全，隐式提交 注意: 表单数据的提交，要提交的表单项必须拥有name属性值，否则不会提交 提交的表单数据为键值对，键为name属性的值，值为用户书写的数据 注意:form标签会收集其标签内部的数据 注意:form表单的数据提交需要依赖于submit的提交按钮 form表单域标签: 作用:给用户提供可以进行数据书写或者选择的标签 使用: 文本框: input type: text 收集少量文本数据，用户可见 password 收集密码数据，用户不可见 name 数据提交的键，也会被js使用 单选框: input type: radio name:name属性值相同的单选框只能选择其中一项 value:要提交的数据 checked:checked 使用此属性的单选默认是选择状态 多选框: input type: checkbox name:一个多选组需要使用相同的name属性 value:要提交的数据 checked:同上，为checked则默认选中 下拉框: select: name:数据提交的键名，必须声明 子标签option:一个option标签表示一个下拉选项 文本域: textarea:声明一个可以书写大量文字的文本区域 name:数据提交的键名，js和css也可以使用 rows:声明文本域的行数 cols: 普通按钮: input: type: button 隐藏标签: input: type: hidden name: value: 注意:表单数据提交，提交的是表单域标签的value值 form表单标签的使用: 在点击数据提交时，form标签会将其内部所有form表单域标签中用户书写的数据 按照method指明的提交方式提交给action属性所指明的提交地址 form标签 --&gt;","link":"/2019/12/21/前端/HTML笔记/"},{"title":"UI控件设计","text":"界面设计与功能开发同样重要 基础控件在活动对应的XML文件中，可通过编写XML信息来进行控件的添加和内容设计 对于每个控件，有若干必填属性，android:id android:layout_width android:layout_height TextView 文本控件需添加 id 和 text gravity 属性：控制文本的放置方向，可以利用 | 来添加多个值。 center 等价于 center_vertical|center_horizontal textSize：调整字体大小，单位是sp，如 24sp textColor：调整颜色，如 #00ff00 Button 按钮控件textAllCaps：是否将英文字母自动装换为大写，True或 False EditText 交互控件既输入框 maxLines：该控件最大显示的行，输入内容超过后将向上滚动 hint：未输入前输入框中显示的内容 ImageView 图片展示控件src：设置图片资源 ProcessPar 进度条控件max：最大进度 style：进度条风格，?android:attr/progressBarStylexxx AlertDialog 对话框控件弹出式对话框控件，无需在XML文件中添加，直接在程序中按钮的点击时间中设定即可 .setTtile()：弹出框标题 .setMessage()：文本内容 .SetCancelabel()：是否可按返回键取消 .setPositiveButton()：确定按键 .setNegativeButton()：取消按键 ProgressDialog 另一个对话框控件操作基本同上，区别在于会显示进度条，没有确定和取消按钮，操作完成后，记得调用 dismiss()，不然对话框将一直存在 基本布局线性布局控件将在线性方向上依次排列，通过 android:orientation 可指定排列方向 竖直排列：vertical 水平排列：horizontal，此时无法将控件宽度指定为match_parent 相对布局通过设定各个控件在整个布局中的相对位置，及彼此间的相对位置，来合理摆放控件 帧布局所有控件默认摆放在布局的左上角 百分比布局略过 另外，还可创建自定义布局","link":"/2019/10/26/安卓/UI控件设计/"},{"title":"前向神经网络和误差反向传播算法","text":"简要介绍前向神经网络和误差反向传播算法 什么是前向神经网络？概率其实很简单，首先，是神经网络的一种，哪一种呢？前向！ 再解释前向神经网络之前，先简单提一嘴神经网络，神经网路是模拟人的神经结构而来的一种理论模型，由若干单个神经元构成，每个神经元接收一个输入（多个输入时可以认为先将其按一定规则累加为一个输入），产生一个输出。若干神经元分层排列相连就构成了神经网络。 前向神经网络指的是这样一种神经网络： 第$i$层的每个神经元与第$i+1$层的每个神经元都建立连接（全连接） 任一连接都必须是从前一层神经元指向后一层的神经元（前向） 前向神经网络包括三部分：输入层、隐藏层和输出层，各连接（有向箭头）都是带有自身属性的——权重。 多层神经网络（也可以理解为是多层感知机）的好处：可模拟（拟合）非线性函数，实际上两层神经网络就可以模拟任意非线性函数（当然，每层可能需要较多的神经元） 反向误差传播算法目的：更新权重参数值，使得神经网络最好地与问题拟合。 把握关键点之后很简单，由于反向误差传播算法的具体运用是通过借助梯度下降算法，那么，在反向误差传播算法中，实际上传播的误差并不是绝对误差值，而是：梯度 而梯度值的计算，是从后往前，所以称为反向，首先根据最后的损失函数，计算出终点的误差梯度值，然后通过简单的连续偏导数运算可以得到所有权重参数的梯度值，按照选好的步长值$\\lambda $进行更新： w^l_{ij}(k+1) = w^l_{ij}(k) - \\lambda \\Delta^l_{ij}注： 式子中，$w^l_{ij}(k+1)$表示表示神经网络中第$l$层第$i$个神经元到下一层第$j$个神经元的权重参数值，迭代次数为$k+1$次 $\\Delta^l_{ij}$上下标同上含义，表示该次迭代时该位置的权重参数所对应的误差梯度","link":"/2019/12/08/数据科学/前向神经网络和误差反向传播算法/"},{"title":"基本认识","text":"写大作业需要做一个安卓端程序（只要能与电脑远程连接并发送和接受消息即可），于是下了本《第一行代码》电子版看了几天，期间有一些收获，便写在这。 Android(原生)设计的重要特点：逻辑和视图分离 第一次上手发现安卓项目的目录结构就很复杂，结合书上的介绍和网上的一些博客才明白一些，所谓逻辑和视图分离，指的是功能和界面是单独设计的，并放在不同的文件目录之中。功能设计代码放在main文件夹当中Java文件夹下，为Java文件，界面设计则放在main文件夹中的res文件夹下，为XML文件。 似乎现在大多不采用原生的这一套设计，而是借助Flutter框架进行软件开发，这个框架也是由谷歌所推出，然而菜鸡如我与之距离还比较遥远，以下内容大多算是看书时的一些笔记了。 所有以drawable开头的文件夹都是用来放图片的,所有以mipmap开头的文件夹都是用来放应用图标的,所有以values开头的文件夹都是用来放字符串、样式、颜色等,layout文件夹是用来放布局文件的。可自行添加menu，用于软件的展开栏。 基本操作添加Button：首先在对应的xml文件中加入Button，并创建id，然后在Java代码中重载的OnCreate模块中加入创建Button实例并链接到id，之后可设计一些Button的响应操作 Toast：可与Button进行联动，当按Button时，会在屏幕下方弹出一块文本信息，一段时间后消失 finish()：Button点击行为中，此函数意味着活动销毁，即返回操作 Intent：用于组件（或视图）间的交互，可指定行为，也可以传递数据； 具有显式（传递两个组件的类）和隐式（通过参数action、category） 显式例子： 12Intent intent = new Intent(FirstActivity.this, SecondActivity.class)startActivity(intent); 隐式例子： 123Intent intent = new Intent(Intent.ACTION_VIEW);intent.setData(Uri.parse(\"http://www.baidu.com\"));startActivity(intent); startActivity()：用于启动活动，参数可为Indent对象 在AndroidManifest.xml中，每个活动下的&lt;data&gt;标签可配置以下内容： android:scheme 。用于指定数据的协议部分,如上例中的http部分。 android:host 。用于指定数据的主机名部分,如上例中的www.baidu.com部分。 android:port 。用于指定数据的端口部分,一般紧随在主机名之后。 android:path 。用于指定主机名和端口之后的部分,如一段网址中跟在域名之后的内容。 android:mimeType 。用于指定可以处理的数据类型,允许使用通配符的方式进行指定。 只有当&lt;data&gt;标签中指定的内容与Intent中携带的Data完全一致时，当前的活动才能够相应该Intent Android是使用任务(Task)来管理活动一个任务就是一组存放在栈里的活动的集合,这个栈也被称作返回栈(Back Stack) 活动的状态： 运行 暂停 停止 并不意味着活动销毁，如一个界面有多个窗口时，非正在使用的窗口就是停止状态 销毁 活动的生存期：7种，都在Activity类中调用 onCreate() 完成活动的初始化操作，如加载布局、绑定事件 onStart() 在活动有不可见变时调用 onResume() 在活动准备好和用户进行交互的时候调用。此时的活动一定位于返回栈的栈顶,并且处于运行状态 onPause() 系统准备去启动或者恢复另一个活动的时候调用。通常会在这个方法中将一些消耗CPU的资源释放掉,以及保存一些关键数据,但这个方法的执行速度一定要快,不然会影响到新的栈顶活动的使用。 onStop() 活动完全不可见的时候调用。它和 onPause() 方法的主要区别在于,如果启动的新活动是一个对话框式的活动,那么 onPause() 方法会得到执行,而 onStop() 方法并不会执行。 onDestroy() 在销毁前调用，之后活动的状态将变成销毁状态 onRestart() 在由停止台变为运行态之前调用 当系统内存不够，活动被系统收回，导致临时数据丢失，怎么处理？onSaveInstanceState() 回调方法：可以保证在活动被回收之前一定会被调用,因此我们可以通过这个方法来解决活动被回收时临时数据得不到保存的问题。 onCreate() 方法其实也有一个 Bundle 类型的参数。这个参数在一般情况下都是 null ,但是如果在活动被系统回收之前有通过 onSaveInstanceState() 方法来保存数据的话,这个参数就会带有之前所保存的全部数据,我们只需要再通过相应的取值方法将数据取出即可。 Intent还可以结合 Bundle 一起用于传递数据,首先可以把需要传递的数据都保存在 Bundle 对象中,然后再将 Bundle 对象存放在Intent里。到了目标活动之后先从Intent中取出 Bundle ,再从 Bundle 中一一取出数据。 启动模式 standard singleTop singleTask singleInstance 选定方法：在AndroidManifest.xml中通过给&lt;activity&gt;标签指定android:launchMode属性","link":"/2019/10/24/安卓/基本认识/"},{"title":"多元线性回归","text":"只做简要介绍和理解 理论问题与一元线性回归基本类似，只是对变量进行了扩充，在表达式向量化之后可写成与一元线性回归相同的形式。 由于所含参数、下标（分量）较多，首先得形式化定义问题。 下式为多元线性回归数学模型，式中$x,w$分别为自变量（特征），参数（权重）的向量值，(设向量长度为$m$)： y = xw^Tx=（x_1,x_2,\\cdots,x_m)^T;\\ w = (w_i, w_2,\\cdots,w_m)^T设给定样本组数为$n$，对于自变量和因变量的随机变量，设为$X,Y$，单个样本为： (X_i, Y_i),i=1,\\cdots,n单个样本的单个分量为（第$i$个样本的第$j$个分量，之后的式子中$i$表示样本序号，$j$表示单个样本的分量值序号，$Y$为单分量数据，即$Y\\in \\mathbb{R}$）: X_{ij}损失（误差）函数定义如下： L = \\frac{1}{2}MSE = \\frac{1}{2}\\sum_{i=1}^{m}(Y_i-X_iw^T)^2对上式子损失进行向量化（向量化思维非常重要，能极大简单求解过程，最右侧为$L_2$范数）： L=\\frac{1}{2}(Y-Xw)^T(Y-Xw)=\\frac{1}{2} ||Y-Xa||_2注： 损失函数乘上二分之一没有特别意义，只是为了求导之后没有常系数 $X,Y$的完整矩阵（向量）结构如下： X= \\left\\{ \\begin{matrix} X_{11} & X_{12} & \\cdots & X_{1m}\\\\ X_{21} & X_{22} & \\cdots & X_{2m} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ X_n1 & X_{n2} & \\cdots & X_{nm} \\end{matrix} \\right\\}Y = (Y_1,Y_2, \\cdots, Y_n)求解对损失函数求导，令偏导为$0$，解参数$w$: \\frac{\\partial L}{\\partial w} = X^T(Y-Xw) =0X^TY=X^TXww = (X^TX)^{-1}X^TY注：也可通过梯度下降进行求解 引伸（也可称为正则化手段）Ridge Regression（岭回归、脊回归）上面的求解结果中，Ｘ^TX可能不可逆，解决办法，给原始损失函数加上一个惩罚项（二范数）： L = \\frac{1}{2}\\sum_{i=1}^{n}(Y_i-X_i^Tw) + \\frac{1}{2}\\lambda w^Tw则求偏导解得： w = (X^TX+\\lambda I_m)^{-1}XY其中X^TX为半正定矩阵， \\lambda I_m为正定矩阵，两者相加为正定矩阵，可逆 Lasso损失函数加上一范数（绝对值）的惩罚项 L = \\frac{1}{2}\\sum_{i=1}^n(Y_i - X_i^Tw)+\\frac{1}{2}\\lambda ||a||_1此时，所得参数$a$的部分分量值为$0$，带来的好处：能消掉部分无关特征 Elastic Net惩罚项既有一范数又有二范数。一范数能带来稀疏，二范数能带来计算便利和求导。此处知识点待了解。 实践操作基本同一元线性回归，同一个API，毕竟LinearRegression就是针对所有线性回归情况，样本读取和数据拆分略过。调用、fit、预测如下： 1234from sklearn.linear_model import LinearRegressionregressor = LinearRegression()regressor.fit(X_train, Y_train)Y_pred = regressor.predict(X_test)","link":"/2019/12/08/数据科学/多元线性回归/"},{"title":"数据预处理","text":"从这篇文章开始，跟着Github上的100-Days-Of-ML-Code项目进行实践学习，途中结合其它资源。 导入库12import numpy as npimport pandas as pd 读数据(通常为csv文件)12345dataset = pd.read_csv('data.csv')# pd.read_csv()返回类型为DataFrame，默认增加的行索引X = dataset.iloc[:, :-1].values# .iloc进行按位置序号索引，此处数据为二维，.values可将其转化成ndarray（即矩阵或者向量）Y = dataset.iloc[:, -1].values 处理丢失数据（nan，此处X中存在nan）：利用sklearn.impute库中的SimpleImputer 123456789from sklearn.impute import SimpleImputer'''参数及默认，mean意为以该列平均值进行填充SimpleImputer(missing_values=nan, strategy='mean',fill_value=None,verbose=0,copy=True,add_indicator=False)使用方法：定义、fit、transfrom'''imputer_mean = SimpleImputer() # 默认值即可imputer = imputer_mean.fit(X[:, 1:]) # 只能接受数值型数据，根据数据fit出应该填充的数据X[:, 1:3] = imputer.transform(X[:, 1:]) # 进行填充 解析分类数据对于分类结果，源数据常常为Yes或No，不适应计算，应将其转化为数字1或0，另外数据的部分输入属性也非数据，可转化成数据 利用sklearn.preprocessing的LabelEncoder, OneHotEncoder 12345678910from sklearn.preprocessing import LabelEncoderle_y = LabelEncoder()Y = le_y.fit_transform(Y) # fit_transform将fit和transform两操作结合起来'''原本Y为['No', 'Yes', 'No', 'No', 'Yes', 'Yes', 'No', 'Yes', 'No', 'Yes']转换后为[0, 1, 0, 0, 1, 1, 0, 1, 0, 1]LabelEncoder().classes_保存着两者的对应表，此处的le_y.classes_为 ['No', 'Yes']''' 数据集拆分（成测试集和训练集）利用sklearn.model_selection 的train_test_split() 123from sklearn.model_selection import train_test_splitX_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=0)# test_size用于设置拆分比例，0.2即20%的训练集，可增加参数shuffle，用于设置拆分前是否对数据进行混洗，默认为True，random_state设置随机数种子 特征缩放不同特征在幅度、取值范围、单位上变化很大。计算距离时，高幅度的特征比低幅度的特征占据更大权重。可通过特征标准化或Z值归一化进行处理，下面采用标准特征化（即让各个特征取值大小差不多）。 1234from sklearn.preprocessing import StandardScalersc_X = StandardScaler()X_train = sc_X.fit_transform(X_train)X_test = sc_X.fit_transform(X_test)","link":"/2019/12/01/数据科学/数据预处理/"},{"title":"基本分布知识","text":"基本分布知识 离散型 伯努利分布 $\\{b(n,p);0&lt;p&lt;1\\}$ 几何分布 $\\{Ge(p);0&lt;p&lt;1\\}$ 泊松分布 $\\{P(\\lambda);\\lambda&gt;0\\}$ 连续型 正态分布 $\\{N(\\mu,\\sigma^2);-\\infty&lt;\\mu&lt;+\\infty,\\sigma&gt;0\\}$ 指数分布 $\\{Exp(\\lambda);\\lambda&gt;0\\}$ 均匀分布 $\\{U(a,b);-\\infty&lt;a&lt;b&lt;+\\infty\\}$ 抽样分布： 卡方分布 $\\chi^2(n)$ T分布 $t(n)$ F分布 $F(m,n)$ 样本均值抽样分布 $\\overline{X}$~$N(\\mu ,\\sigma^2/n)$ 样本均值与标准差之比的分布 $\\frac{\\overline{X}-\\mu}{S_n/\\sqrt{n-1}}$~$t(n-1)$ 两个独立正态总体的抽样分布 $\\frac{(\\overline{X}-\\overline{Y})-(\\mu_1-\\mu_2)}{\\sqrt{\\sigma^2_1/m+\\sigma^2_2/n}}$~$N(0,1)$ 概率分布不同于抽样分布，其差别犹如概率论与统计学，虽然概率论可以算在统计学范畴之中，但细节上而言两者的出发点是不同的，前者是知道整体的模型和分布，来计算抽样的各类概率，而后者是从局部出发，透过局部信息来获得（或者说是估计）整体信息。 几大抽样分布都来源于正态分布，正态分布也叫高斯分布，很好的描述了生活中诸多随机事件的发生概率分布。","link":"/2019/11/22/统计/基本分布知识/"},{"title":"方差分析","text":"方差分析 目的检验不同样本是否具有相同的均值（在基本假定条件下，即检验样本是否来自同一个正态总体） 方式：通过对各观察数据误差来源进行分析，来判断多个总体均值是否相等 基本思想和原理两类误差：随机误差和系统误差 两类方差：组内方差和组间方差 通过比较两类误差，来检验均值是否相等（利用方差比） 组内方差是只含随机误差的（通常是抽样的随机性引起），而组间方差即包括随机误差也包括系统误差（系统误差由不同组自身差异导致），这时组间方差除以组内方差结果就会大于一。将两者相除，如果样本均值相同，那么结果应该为1。当该比值大到某种程度时，就说不同样本间存在显著差异。 基本假定 每个总体都应该服从正态分布 每个总体的方差必须相同 观察值独立 假设零假设：各样本具有相同均值；$H_0:\\mu_1=\\mu2=…=\\mu_k$ 备择假设：各样本均值不全相同；$H_1:\\mu_1,\\mu_2,…\\mu_k$不全相等 统计量构造组内均值 $\\overline{X_i}=\\frac{\\sum_{j=1}^{n_i}x_{ij}}{n_i},(i=1,2,…,k)$ 总体均值 $\\overline{X }=\\frac{\\sum_{i=1}^{k}\\sum_{j=1}^{n_i}x_{ij}}{n}=\\frac{\\sum^k_{i=1}n_i \\overline{x_i}}{n}, n=n_1+n_2+…+n_k$ 总离差平方和 $SST$ 组内离差平方和 $SSE$ 水平项平凡和（组间平方和） $SSA$ 三平方和间有着如右式的关系：$SST = SSE + SSA$ 注： $SST$反映了全部数据总的误差程度；$SSE$反映了随机误差的大小；$SSA$反应了随机误差和系统误差的大小。 若原假设成立，则表明没有系统误差，那么$SSA$除以自由度之后的均方与$SSE$除以自由度之后的差异就不会太大 $SST$ ,$SSA$, $SSE$三者的自由度分被是$n-1$,$k-1$,$n-k$ 计算均方（方差）$MS$$MSA$: $SSA$的均方，组间方差 MSA=\\frac{SSA}{k-1}$MSE$: $SSE$的均方，组内方差 MSE=\\frac{SSE}{n-k}比较组间方差和组内方差，构造$F$F=\\frac{MSA}{MSE}～F(k-1,n-k)统计决策给定显著性水平$\\alpha$，通过查$F$分布表得到与第一自由度和第二自由度相对应的临界值$F_\\alpha$，然后比较通过样本计算而得的$F$值和临界值$F_\\alpha$，若$F&gt;F_\\alpha$，则拒绝原假设$H_0$，否则接收该假设。 方差分析中的多重比较多重比较：通过对总体均值之间的配对比较来进一步检验到底那些均值之间存在差异 最小显著差异方法（由Fisher提出），简称LSD，（模式识别PPT里运用过） 示范：（基于统计量$\\overline{x_i}-\\overline{x_j}$的$LSD$方法） 通过判断样本均值之差的大小来检验$H_0$ 检验的统计量为$\\overline{x_i}-\\overline{x_j}$ 检验步骤： 提出假设（$H_0$为第$i$个总体均值等于第$j$个总体均值、$H_1$） 计算$LSD$ （$LSD=t_{\\alpha/2}\\sqrt{MSE(\\frac{1}{n_i}+\\frac{1}{n_j})}$） 若$|\\overline{x_i}-\\overline{x_j}|\\geq LSD$，拒绝原假设$H_0$，否则不能拒绝原假设","link":"/2019/11/26/统计/方差分析/"},{"title":"统计_intro","text":"开始学习统计 最近准备下点功夫好好学概率统计，基本上是从头开始学，学习途中记录下个人较细节的感受、思考和收获，同时好好梳理其内容。 统计学的魅力，我认为就在于其实际效用，它来源于实际问题，也充分有效的反馈于实际问题，极其实用且传递了一套独具一格的思维方式，更加现代且高屋建瓴，让现实中捉摸不定的问题有了分析的切入点。 主要参考如下： 数理统计讲义 华南理工 何志坚 https://bookdown.org/hezhijian/book 数理统计PPT 华中科技大学 何娟 概率论与数理统计 浙江大学 盛骤、谢式千、潘承毅 内容主要学习内容为：抽样、参数估计、假设检验、（非参数估计） 统计学大致分类：描述统计、推断统计、理论统计、应用统计 脉络介绍（简要目录）以下简要列出各部分的主要内容 抽样 抽象方法 抽象分布 参数估计 点估计 区间估计 分布估计 假设检验 UMP检验 广义似然比检验 多重检验 伯努利分布检验 卡方检验 线性回归 一元线性回归 多元线性回归 回归诊断","link":"/2019/11/21/统计/统计_intro/"},{"title":"requests库笔记","text":"对于库的选择和Robots协议作基本介绍，requests库见官方中文文档 网络爬虫规模及爬虫库的选择 小规模。当数据量小，且对爬取速度不敏感时采用Requests库 中规模。当数据规模较大，且对爬去速度敏感时采用Scrapy库 大规模。 全网爬取(搜索引擎)，且爬取速度特别关键时需定制开发 如何对网络爬虫进行限制 来源审查：判断User-Agent并进行限制，检查HTTP协议头部的User-Agent，通过一定的设定后策略，只相应允许的User-Agent进行访问 发布公告：通过Robots（Robots Exclusion Standard）协议，将网站的爬取策略（一个txt文件）告诉所有爬虫，要求按照规则对网页进行爬取 （网络爬虫也可以不遵守Robots协议，但是存在着法律风险） 1234567891011121314# Robots demo from www.jd.com/robot.txt# 网络爬虫应该能自动识别robots.txt，并根据内容进行爬取User-agent: * Disallow: /?* Disallow: /pop/*.html Disallow: /pinpai/*.html?* User-agent: EtaoSpider Disallow: / User-agent: HuihuiSpider Disallow: / User-agent: GwdangSpider Disallow: / User-agent: WochachaSpider Disallow: /","link":"/2019/09/27/网络爬虫/requests库笔记/"},{"title":"BeautifulSoup库笔记","text":"网页信息解析库 使用方式： 12from bs4 import BeautifulSoupsoup = BeautifulSoup('&lt;html&gt;data&lt;/html&gt;', 'html.parser') 只要提供的是标签数据，beautifulsoup库都能做很好的解析，可以讲数据处理成树状结构数据 基本标签和解释器共有四类解释器：html.parser、lxml、xml、html5lib （其中lxml也是处理HTML的解释器，xml也可以写作lxml-xml） 共有五种基本元素： Tag(标签)，指整个标签 Name(标签的名字) ttributes(标签的属性)，为字典类型，存储了标签的各属性值，如class、href、id等。1. 通过.attrs可获取标签所有的属性 2. 通过类似字典的操作访问，如tag[‘class’] NavigableString(标签内的非属性字符串)，字符串，为标签内的字符串信息，通过.string获取，若标签只有一个子节点，也可以通过.string直接获取子节点的字符串内容 Comment(标签内字符串的注释部分)，不常用，注释是利用!—符号构成的内容&lt;!--This is a comment--&gt;，如，通过NavigableString类可以直接显示其文本内容，不会注明为注释，需要利用一些手段进行自行判断，comment也是一种NaviableString 遍历操作由于BeautifulSoup对象为树结构，可进行上行、下行和平行遍历 下行遍历 .contents 获得子节点列表，将所有子节点存入列表，可通过列表结构进行选择性地访问 .children 获得子节点的迭代类型，与.contents类似，用于循环遍历子节点 .descendants 获得子孙节点的迭代类型，包含所有的子孙节点，用于循环遍历 上行遍历 .parent 获得节点的父节点标签，其中根节点的父节点为自身 .parents 可获得节点的所有先辈标签的迭代类型 平行遍历 .next_sibling 返回按照HTML文本顺序的下一个平行节点标签 .previous_sibling 返回按照HTML文本顺序的上一个平行节点标签 .next_siblings 迭代类型,返回按照HTML文本顺序的后续所有平行节点标签 .previous_siblings 迭代类型,返回按照HTML文本顺序的前续所有平行节点标签 注意 导入时需要注意，from bs4 import BeautifulSoup，而不是直接导入BeautifulSoup 利用beautifulsoup处理网页内容时，除了网页内容，还需要给出一个解释器，如html.parser或者lxml 利用BeautifulSoup.prettify()可将处理过得网页内容（beautifulsoup对象或者标签）有层次（增加换行符）得再现出来，prettify()方法只能作用于BeautifulSoup对象 bs4库默认将所有HTML输入都变成utf-8编码，而由于Python 3以上的版本默认支持编码为utf-8所有解析无障碍，但如果是Python 2的版本，则会出现编码上的问题 信息标记的若干形式 XML(eXtensible Markup Language） —最早的通用信息标记语言，可拓展性好，但略繁琐。适合Internet上的信息交互与传递 内容： … &lt;\\name&gt; 注释： JSON(JavaScipt Object Notation) —信息有类型，适合程序处理(js)，较XML简洁，但无法表示注释。适合移动应用云端和节点的信息通信 从名字可以看出是面向对象的一种表达方式，内容采用类型的键值对key: value进行表示 并列内容采用, 进行分隔 注意：字符串都是用双引号表示，单引号不可以，当值的信息有多个时，才有[ , ]的形式进行组织，可以嵌套，如果嵌套的对象为键值对，则需要用{}符号 YAML(YAML Ain’t Markup Language) —信息无类型，文本信息比例最高，且有注释，可读性高。适合各类系统的配置文件 采用无类型的键值对进行信息存储，通过缩进格式来表示信息的嵌套（层次关系） 采用-号表示并列关系 采用#进行注释 采用|进行整块数据的表达 信息提取的方法 形式解析（需要标记解释器） 无视搜索（需要文本查找函数 ） 融合搜索（需要标记解析器和文本查找函数） 文本查找函数（过滤器）： &lt;&gt;.find() &lt;&gt;.find_all(name, attrs, recursive, string, **kwargs) 返回一个列表类型，存储查找的结果 name:对标签名称的检索字符串 attrs:对标签属性值的检索字符串，可标注属性检索 recursive:是否对子孙全部检索，默认为True string:...中字符串区域的检索字符串 如果传入参数为列表，Beautiful Soup会将与列表中任一元素匹配的内容返回 参数也可以为方法 可以通过 find_all() 方法的 attrs 参数定义一个字典参数来搜索包含特殊属性的tag 注意：(…) 等价于 .find_all(…); soup(…)等价于 soup.find_all(…) 拓展方法： &lt;&gt;.find() 搜索且只返回一个结果,同.find_all()参数 &lt;&gt;.find_parents() 在先辈节点中搜索,返回列表类型,同.find_all()参数 &lt;&gt;.find_parent() 在先辈节点中返回一个结果,同.find()参数 &lt;&gt;.find_next_siblings() 在后续平行节点中搜索,返回列表类型,同.find_all()参数 &lt;&gt;.find_next_sibling() 在后续平行节点中返回一个结果,同.find()参数 &lt;&gt;.find_previous_siblings() 在前序平行节点中搜索,返回列表类型,同.find_all()参数 &lt;&gt;.find_previous_sibling() 在前序平行节点中返回一个结果,同.find()参数","link":"/2019/09/27/网络爬虫/BeautifulSoup库笔记/"},{"title":"正则表达式","text":"简单介绍正则表达式的思想及用法 什么是正则表达式 用来简洁表达一组字符串的表达式 一种通用的字符串表达框架 可以用来判断某字符串的特征归属 更是一种针对字符串表达“简洁”和“特征”思想的工具 独特优势简洁高效，用来简洁表达一组字符串，主要使用在字符串匹配中（一行胜千言） 语法构成由字符和操作符构成 操作符 说明 实例 . 表示任何单个字符(除了\\) [ ] 字符集,对单个字符给出取值范围 [abc]表示a、b、c,[a‐z]表示a到z单个字符 非字符集,对单个字符给出排除范围 abc表示非a或b或c的单个字符 * 前一个字符0次或无限次扩展 abc* 表示 ab、abc、abcc、abccc等 + 前一个字符1次或无限次扩展 abc+ 表示 abc、abcc、abccc等 ? 前一个字符0次或1次扩展 abc? 表示 ab、abc \\ 左右表达式任意一个 abc {m} 扩展前一个字符m次 ab{2}c表示abbc {m,n} 扩展前一个字符m至n次(含n) ab{1,2}c表示abc、abbc ^ 匹配字符串开头 ^abc表示abc且在一个字符串的开头 $ 匹配字符串结尾 abc$表示abc且在一个字符串的结尾 ( ) 分组标记,内部只能使用\\ 操作符 (abc)表示abc, （abc\\ def）表示abc、def \\d 数字,等价于[0‐9] \\w 单词字符,等价于[A‐Za‐z0‐9] 补充： 匹配中文字符 1[\\u4e00-\\u9fa5] 匹配IP地址(4段，每段为0-255) 1((25[0-5]|2\\d{0-4}\\d|1\\d{2}|[1-9]?\\d).){3}(25[0-5]|2\\d{0-4}\\d|1\\d{2}|[1-9]?\\d) 使用正则表达式编译（将符合正则表达式语法的字符串转换成正则表达式特征） python中使用1import re re库需要采用raw string类型(字符串中的\\不被理解为转移符，如果用string就会比较繁琐)表示正则表达式，表示为r'text' 通过group方法，可以获取正则表达式中的字符串 12345re.search(r'text').group()re.search(r'text').group(0) # 与上行相同，反正整体匹配字符串re.search(r'text').group(1) # re.search(r'text').group(2)re.search(r'text').group(3) 匹配规则贪婪匹配：匹配字符串为满足条件的最长字符串 通过在匹配规则中加上?可以进行最小匹配","link":"/2019/09/27/网络爬虫/正则表达式/"},{"title":"论文阅读（A surbey on network embedding）","text":"读论文 what is network embedding?Network embedding assignes nodes in a network to low-dimensional representations and effectively preserves the network structure. 网络嵌入将网络中结点映射到低维空间表示，并且能有效地保存网络的结构。 usually model the network structure in the two-dimensional embedding space. 通常在两维空间内对网络结构进行建模 The intrinsic problem is to learn a mapping function between these two spaces. 最本质的问题是学习两空间的映射关系 what does this paper focuses on? categorizing and reviewing the current development on … provide a comprehension overveiw of a large nubmer of network embedding methods traditional graph presentation and its shortcomings?$G$, $V$ is a vertex set where $E$ is an edge set. $E$ is usually in the adjacency matrix form 采用邻接矩阵的方式 Traditional presentation method doesn’t suit for large scale graph computation and application in real-world networks. in detail, it comes with problems: High computational complexity Low parallelizability(parallel and distributed computing). traditional methods make it hard to design the implementation of parallel and distributed computing. Inapplicability of machine learning methods. hard to be vectorized Those methods(such as deep learning) usually assume that data samples can be represented by independent vectors in a vector space, while the samples in network data (i.e., the nodes) are dependant to each other to some degree determined by E . 像深度学习这类方法通常认为数据样本可用向量空间内独立的向量表示，但网络数据中的样本彼此具有一定程度的依赖（边所导致）。 The traditional network representation has become the bottleneck in large-scale network processing and analysis. （传统网络的表示方式已然成为了大规模网络处理和分析的瓶颈） Concrete network embedding idea?use distance to capture the relationships among the nodes, and use embedding vector to encode the topological and structural characteristics of a node. （采用距离来获取结点间的关系，采用嵌入向量来存储单个结点的拓扑和结构特征） it supports for subsequent network processing and analysis tasks(such as node classification, node clustering, network visualization and link prediction). （采用标量和向量的好处：支持后续的网络处理和分析任务，诸如结点分类、结点聚类、网络可视化、链路预测） Two goals for network embedding to well support network analysis tasks? Network Reconstruction(Distance corresponding). that is: if there is an edge or relationship between two nodes, the distance should be relatively small Supporting Network Inference Paper frameworkChapter 2. categorize methods and summarize models. Chapter 3. review models and discuss differences. Chapter 4,5,6. respectively review the methods on structure and property network embedding. Chapter 7. present a few evaluation scenarios and some online resources. Chapter 8. conclusion and proposals. Categorization of the existing methods(three catrgories) network structure and properties preserving network embedding (拓扑结构的保存) side information preserving network embedding ( 结点内容或者结点、边的标签数据) advanced information preserving network embedding (构造监督学习，网络结构作为输入，结点标签数据作为输出，端到端学习)(domain knowledge) Commonly used models in network embedding matrix factorization. Singular Value Decomposition(SVD) is often used for its optimality for low-rank approximation. Non-negative matrix factorization is often used because of its advantages as an additive model. random walk. Similar to Word2Vec in NLP, regard a node as a word, and regard a random path as a sentence. deep neural networks and their variations. The key challenges are how to make deep models fit network data, and how to impose network structure and property-level constraints on deep models. What’s the differences between graph embedding and network embedding? 图嵌入和网络嵌入两方面：目标（objective）和假设（assumption） 目标：(Substantial difference)图嵌入着重于构造图的结构，而网络嵌入有两大目标（构造网络结构和网络推测） 假设：图嵌入的图构造自特征表示数据集（feature represented data sets），即本身有比较好的定义，边的权重可以表示结点相似性。网络嵌入处理的是自然形成的网络图，结点相似性需要经过特定分析或基于特性应用场景定义。 Structure preserving network embedding网络结构分类:first-order, higher-order(second-order, community) 代表方法： DeepWalk Node2Vec LINE SDNE Property preserving network embedding主要研究的属性：network transitivity, structural balance property Advanced information preserving network embedding通常包含两部分：保存网络结构（以学到结点的表示）、建立结点表示和目标任务间的关系 常用数据集（academic research）大致分类： social networks citation networks language networks biological networks ApplicationsNode Classification (Steps as followed) apply a network embedding algorithm to embed the network into a low dimensional space use the nodes with known labels as training set from the training set, learn a classifier Link prediction Node clustering Network Visualization Some tables about algorithms, datasets, source codes Some directions How to incorporate network motifs To what extent the assumption(there is an agreement between network and side information) holds in real application Incorporate unique domain knowledge into network embedding New algorithms for tackling dynamic nature of evolving networks Exploring other embedding space [1]: Cui P, Wang X, Pei J, et al. A survey on network embedding[J]. IEEE Transactions on Knowledge and Data Engineering, 2018, 31(5): 833-852.","link":"/2019/12/17/论文阅读/论文阅读（A surbey on network embedding）/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"读书笔记","slug":"读书笔记","link":"/tags/读书笔记/"},{"name":"个人","slug":"个人","link":"/tags/个人/"},{"name":"周记","slug":"周记","link":"/tags/周记/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"LaTeX","slug":"LaTeX","link":"/tags/LaTeX/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"PyQt","slug":"PyQt","link":"/tags/PyQt/"},{"name":"数据科学","slug":"数据科学","link":"/tags/数据科学/"},{"name":"前端","slug":"前端","link":"/tags/前端/"},{"name":"安卓","slug":"安卓","link":"/tags/安卓/"},{"name":"统计","slug":"统计","link":"/tags/统计/"},{"name":"网络爬虫","slug":"网络爬虫","link":"/tags/网络爬虫/"},{"name":"requests库","slug":"requests库","link":"/tags/requests库/"},{"name":"BeautifulSoup库","slug":"BeautifulSoup库","link":"/tags/BeautifulSoup库/"},{"name":"re库","slug":"re库","link":"/tags/re库/"},{"name":"论文阅读","slug":"论文阅读","link":"/tags/论文阅读/"}],"categories":[{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"SE","slug":"Java/SE","link":"/categories/Java/SE/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"个人","slug":"个人","link":"/categories/个人/"},{"name":"语法","slug":"Python/语法","link":"/categories/Python/语法/"},{"name":"读书笔记","slug":"个人/读书笔记","link":"/categories/个人/读书笔记/"},{"name":"各类技术","slug":"各类技术","link":"/categories/各类技术/"},{"name":"月记","slug":"个人/月记","link":"/categories/个人/月记/"},{"name":"GUI","slug":"Python/GUI","link":"/categories/Python/GUI/"},{"name":"数据科学","slug":"数据科学","link":"/categories/数据科学/"},{"name":"周记","slug":"个人/周记","link":"/categories/个人/周记/"},{"name":"前端","slug":"前端","link":"/categories/前端/"},{"name":"安卓","slug":"安卓","link":"/categories/安卓/"},{"name":"统计","slug":"统计","link":"/categories/统计/"},{"name":"网络爬虫","slug":"Python/网络爬虫","link":"/categories/Python/网络爬虫/"},{"name":"论文阅读","slug":"论文阅读","link":"/categories/论文阅读/"}]}