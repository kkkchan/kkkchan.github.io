{"pages":[],"posts":[{"title":"基本数据结构","text":"数组等结构 一维数组用于存储相同数据类型的量，一旦创建，不可更改大小，数组名为引用变量 123456789//声明elementType[] arrayRefVar;//创建elementType[] arrayRefVar = new elementType[arraySize];//初始化elementType[] arrayRefVar = {value0, value1,...,valuek};//匿名数组创建new elementType[]{value0, value1,...,valuek}; 大小如何确定？1.指定大小(创建) 2.默认大小(初始化) 如何复制数组元素（非引用）？ 逐个操作 静态方法 System.arraycopy() clone() 12//arraycopy的使用System.arraycopy(sourceArray, srcPos, targetArray, tarPos, length); 方法中可变参数列表12//typeName... parameterName//一个方法中只能指定一个可变参数，必须放在常规参数之后 java.util.Arrays类该类提供了诸多数组处理的静态方法，如下列几条 sort(numbers) parallelSort(chars, startpos, endpos) binarySearch(arary, pos) equals(array1, array2) fill(array, num); fill(array, startpos, endpos, num) 整体填充数组；部分填充数组 toString(array) 返回包含数组内所有元素的字符串 多维数组创建、初始化同一维数组，只在于括号数量的区别，创建多维数组时，必须指定第一维的大小 锯齿数组锯齿数组指一类多维（以二维为例），其各维的数据长度不同 由于每行本身是一个数组，如果创建时，每行单独创建就可以设置不同的长度","link":"/2019/09/27/基本数据结构/"},{"title":"基本语法结构","text":"分支、条件、循环 分支结构123456789if (true or false){ code block one;}else if (true or false){ code block two;}else { code block three;} 1234567switch (status){ case 0: code one; break; case 1: code two; break; default: code three;} 条件表达式12/* boolean-expression ? expression1 : expression2; */y = (x &gt; 0) ? 1 : -1; 循环结构主要有如下三种循环结构 1234//while型while (true or false){ code block;} 1234//do-while型do { code block;} while (true of false) 1234//for循环型for (i = initialValue; i &lt; endValue; i++){ code block;} 第一和第三种为前测循环，第二种为后测循环 另外还有foreach循环 123for (double e: myList){ System.out.println(e);} 如何创建方法12345/* 修饰符 返回值类型 方法名（参数列表）{ 方法体 }*/ main方法和其它方法的区别：main方法由Java虚拟机进行调用 参数传递为值传递，方法的执行并不会改变原有参数的值 如何进行变量传递？ 调用重载方法时，避免歧义调用（可与多个方法进行匹配，可能会产生编译错误） 注： 程序模块化和可重用性是软件工程的中心目标之一 。 Java 提供了很多有助于完成这一目标的有效结构 。 方法就是一个这样的结构 。 方法签名：方法名和参数列表一起构成方法签名（method signature）","link":"/2019/09/27/基本语法结构/"},{"title":"IO及异常处理","text":"Java异常处理机制及IO处理机制 异常处理重要性：提高程序或软件的健壮性，即即便出现非预期的情景，程序也可以正确的处理 何为异常：一种现象，表示阻止正常进行程序执行的错误或者情况，如果没有被处理，程序就会非正常终止 异常处理的根本优势：将检测错误从处理错误中分离出来 Java中，异常为从异常类中创建的对象 关于异常的类型异常的根类为java.lang.Throwable 异常的分类： 系统错误。由Java虚拟机抛出，用Error类表示，描述的是内部系统错误 异常。用Exception类表示，描述的是由程序和外部环境所引起的错误，这些错误能被程序捕获和处理 运行时异常。用RuntimeException类表示，描述的是程序的设计错误 其中，RuntimeException、Error及其子类称为免检异常（unchecked exception），剩余的其它异常称为必检异常（checked exception），必检异常指编译器会强制程序员检查并通过try-catch块将其处理，或者在方法头进行声明。 异常处理模型123456789101112131415//基于三种操作：声明一个异常、抛出一个异常和捕获一个异常method1(){ try { //异常捕获 invoke method2; } catch (Exception ex){ Process exception; }}method2() throws Exception {//声明异常 if (an error occurs) { throw new Exception(); //抛出异常 }} 异常处理中，可以利用Scanner的方法nextLine()用来丢弃输入行中剩余的输入元素 声明异常方法抛出的必检异常必须在方法头中显式声明，告知调用者可能有出现异常 123public void myMethod() throws IOExceptionpublic void myMethod() throws Exception1, Exception2, ..., ExceptionN 注：如果方法没有在父类中声明异常，就不能在子类中对其进行继承来声明异常 抛出异常123IllegalArgumentException ex = new IllegalArgumentException(\"Wrong Argument\");throw ex; //也可使用匿名类 注：声明异常使用throws，而抛出异常使用throw 注：通常Java API中的每个异常类至少有两个构造方法：一个无参数构造方法、有个带异常描述参数的构造方法，该参数称为异常消息，可以用getMessage()进行获取 捕获异常注：异常捕获中，异常的顺序很重要，子类异常必须放在父类异常之前 JDK7之后，异常捕获可以有多捕获特性： 123catch (Exception1 | Exception2 | ... | Exceptionk ex) { code blocks;} 注：可以利用printStackTrace()方法在控制台上打印出异常的栈跟踪信息 finally字句在try-catch结构中，可加上finally字句，无论 是否产生异常 出现异常是否被捕获 finally字句总是会被执行，当使用finally字句时，可省略掉catch子句 关于何时采用异常处理语句要点：在必须处理不可预料的错误状况时采用 对于简单的、可预料的情况，可以用if-else语句进行处理 IO处理文件对象类java.io.File，该类的对象具有诸多方法，封装了文件或路径的属性，但既不包括创建文件的方法，也不包括从/向文件读/写数据（称为数据输入输出，简称I/O） 对文件进行读写操作写文件： java.io.PrintWriter类 为避免忘记关闭文件，可使用try-with-resources结构进行文件读取（由于在try块中声明和创建资源，块结束后，资源的close()方法会自动调用以关闭资源） 读文件： java.util.Scanner类 1Scanner input = new Scanner(new File(filename));","link":"/2019/09/27/IO及异常处理/"},{"title":"Java基本介绍","text":"基础知识几个缩写 JLS , Java Language Specification, Java语言规范 API, Application Program Interface, 应用程序接口 JDK, Java Development Kit, Java开发工具包 IDE, Integrated Development Environment, 集成开发环境 基本特性描述 simple object oriented distributed interpreted robust secure architecture neutral portable high performance multithreaded dynamic 基础规范 每个Java程序至少需要一个类，类名都是以大写字母开头 程序执行都是从main方法开始，一个类可包含多个方法，但只能有一个main且main为程序开始执行的入口 Java源代码中最多有一个public类 保留字：略 注释：有两种，//是单行注释，*/ * /是多行注释，/** */是文档注释，可以使用javadoc进行注释提取，形成文档 代码块由花括号包围，每行指令结束后需要以分号结尾 Java程序区分大小写 Java源程序为.java文件，编译后的文件为.class文件，文件的编译由Java虚拟机（JVM）进行执行 字符 描述 {} 表示一个代码块 () 和方法一起使用 [] 表示数组 // 引导单行注释 “ “ 包含一个字符串 ; 标示一个语句的结束 注意：在执行一个 Java 程序时 , JVM 首先会用一个称为类加载器 ( class loader ) 的程序将类的字节码加栽到内存中 。 如果你的程序中使用其他类 ,类加栽程序会在需要它们之前动态地加栽它们 。 当加栽该类后 , JVM 使用一个称为字节码验证器 ( bytecode verifier ) 的程序来检验字节码的合法性,确保字节码不会违反 Java 的安全规范 。 Java 强制执行严格的安全规范 , 以确保来自网络的 Java 程序不会篡改和危害你的计算机 。 良好的代码风格 缩进，以表示层次，使得代码清晰、易读 空白，二元运算符两边需各加一个空格 程序错误分类 语法错误 运行错误 逻辑错误 命令行执行 java 用于运行Java文件 javac 用于编译Java文件","link":"/2019/09/27/Java基本介绍/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/09/27/hello-world/"},{"title":"简单程序设计","text":"基操 基本语法包的导入123//import有两种导入import java.util.Scanner; //明确导入import java.util.*; //通配符导入 同一个module下的Java文件无需引用即可使用 输入输出123456789//输入Scanner input = new Scanner(System.in); //Scanner类在包java.util.Scanner中input.nextDouble(); //.nextDouble()用来读取一个double值//输出System.out.println(\"\") ;System.out.printf(\"%4.2f\", m); //格式化输出/*%d 布尔值； %c 字符； %d 十进制整数； %f 浮点数； %e 标准科学计数法形式的数； %s 字符串；*/ Scanner对象的方法 方法 描述 nextByte() 读取一个byte类的整数 nextShort() nextInt() nextLong() nextFloat() 读取一个float类的浮点数 nextDouble() next() 读取一个字符串 nextLine() 读取整行字符串 注意：为了避免错误，不要在 nextByte(), nextShort(), nextInt(), nextLong(), nextFloat(), nextDouble(), next() 之后使用 nextLine()。 输入输出重定向 123java SentinelValue &lt; input.txtjava Classname &gt; output.txtjava SentinelValue &lt;input.txt&gt; output.txt 标识符命名 只能用三类符号: 字母、数字、$ 命名不能以数字开头 常量采用字母全大写形式，在数据类型前需加上 finall 基本数据类型共有8种数据类型（数值、字符值、布尔值数据） 类型 范围 存储大小 byte $-2^7(-128)$ ~ $2^7-127$ 8位带符号整型 short $-2^{15}(-32768)$ ~ $2^{15}-32767$ 16位带符号整型 int $-2^{31}(-2147583648)$ ~ $2^{31}-2147483647$ 32位带符号整型 long $-2^{63}$ ~ $2^{63}-1$ 64位带符号整型 float 负数范围：$-3.402823510^{38}$ ~ $-1.410^{-45}$ 正数范围：$1.410^{-45}$ ~ $3.402823510^{38}$ 32位双精度浮点数 double 负数范围：$-1.797693134862315710^{308}$ ~ $-4.910^{-324}$ 正数范围：$4.9*10^{-324}$ ~ $1.7976931348623157^{308}$ 64位双精度浮点数 此外还有字符类型 char 和逻辑类型 boolean 自动数据类型转换从左到右 byte - char - short - int - long - float - double 引用数据类型 类（class） 接口（interface） 数组（array） 基本数值操作符 运算符 操作 + 加 - 减 * 乘 / 除 % 取余 Math.pow(x, y) 幂运算 逻辑运算 操作符 操作 ！ 逻辑非 &amp;&amp; 逻辑与 || 逻辑或 ^ 逻辑异或 操作符运算优先级 操作符 优先级依次降低 var++, var– 最高级 +, -, ++var, –var (type) ! *, /, % +, - &lt;, &lt;=, &gt;, &gt;= ==, != ^ &amp;&amp; || =, +=, -=, *=, /=, %= 最低级 转义符 转义符 含义 \\b 回退一格 \\t Tab \\n 换行 \\f 换页 \\r 回车 \\\\ 反斜杠 \\&quot; 双引号 character类判断字符类型 方法 功能 isDigit(ch) 判断字符是否为数字，是则返回true，否则返回false isLetter(ch) 是否是字母 isLetterOrDigit(ch) 是否为字母或数字 isLowerCase(ch) 是否是小写字母 isUpperCase(ch) 是否是大写字母 toLowerCase(ch) 返回字符的小写形式 toUpperCase(ch) 返回字符的大写形式 字符串Java中字符串为String类型，String类有如下方法： 方法 描述 length() 返回字符数 charAt(index) 返回指定位置的字符 concat(s1) 将本字符串与字符串s1进行连接，返回新字符 toUpperCase() 将字符串转换成全大写字符的字符串并返回 toLowerCase() 将字符串转换成全小写字符的字符串并返回 trim() 去掉字符串两边的空白字符并返回 equals(s1) 是否等于字符串s1，是则返回true equalsIgnoreCase(s1) 不区分大小写，判断是否等于s1 compareTo(s1) 比较大小，大于、等于或小于，分别返回大于0、等于0、小于0的整数 compareToIgnoreCase(s1) 不区分大小写，同上 startsWith(prefix) 是否以prefix作为前缀开始 endsWith(suffix) 是否以suffix作为后缀结束 contains(s1) s1是否是字符串的子串 substring(beginIndex) 返回 从位置beginIndex到字符串末尾 的字符串 substring(beginIndex, endIndex) 返回从beginIndex到endIndex（不包含endIndex处的字符）的字符串 补充： 将数值型字符串转换成数值 Interger.parseInt(intString) 转换成整数 Double.parseDouble(doubleString) 转换成双精度浮点数 数值可与字符串进行连接构成字符串 String s = number + &quot;&quot;; 获取时间显示当前时间可通过调用 System.currentTimeMillis()， 该方法返回的是从UNIX时间戳（1970年1月1日00:00:00）到当前时刻的毫秒数 软件开发过程 需求规范 需求分析 系统设计 实现 测试 部署 维护","link":"/2019/09/27/简单程序设计/"},{"title":"泛型","text":"Q1：什么是泛型？泛型有什么特点、特性？ Q2：泛型为编程带来了什么优势？ Q3：泛型应该如何设计？ Q4：泛型应用举例？ A1： 泛型是Java中的一种类型，在JDK1.5中引入 A2： 泛型可以使我们定义带泛型类型的类或方法，编译时编译器会用具体的类型来替换它。 使得能够在编译时而不是运行时检测出错误。（解释：即在编写程序时，必须指定泛型类型的具体类型，如果在泛型类型处使用不相符的对象，编译器会检测出错误，提示更改） Java允许定义泛型类、泛型接口和泛型方法。 替换泛型类型的过程称为泛型实例化 泛型类型必须是引用类型","link":"/2019/09/27/泛型/"},{"title":"第一篇博客","text":"喜提自己的博客 经常下午和晚上的摸索，终于搭建起自己的博客，或者说是个人网站，来之不易，希望好好坚持下去！","link":"/2019/09/27/第一篇博客/"},{"title":"类和对象","text":"面向过程范式重在设计方法。面向对象范式重在对象和对象的操作，结合了面向过程范式的功能以及将数据和操作集成在对象中的特点。 重点：面向对象思维 面向对象程序设计的三大支柱：封装、继承、多态 能有助于高效开发GUI和大型软件系统 类和对象的若干细节类是一个模板、蓝本或是合约，用来定义对象的数据域及方法 一个对象是类的实例，创建实例的过程称为实例化 Java类通过使用变量来定义数据域，使用方法来定义动作 构造方法Java类提供了构造方法，可调用它构造一个新的对象，主要是为了完成一些初始化工作，作用是初始化对象。构造方法名与类名相同，参考Python的__init__()及其参数设定 特性： 必须具备与类相同的名字 没有返回值类型，也没有void，举例： public Circle(){ } //没有返回值类型，方法头只有修饰符、方法名和参数列表 是在创新对象时通过new进行调用的 当不定义构造方法时，会隐式定义一个方法体为空的无参构造方法，也称为默认构造方法 匿名对象类似与前面提到过的匿名数组，只是省去了定义过程，直接进行了对象创建，使用时可同时调用其方法，省去不必要的步骤。如： new Circle(5).getArea() 静态变量、常量、方法要点：静态变量（也称类变量）可被类中所有对象共享，静态方法（也称类方法）不能访问类中的实例成员。且无需创建对象就可调用静态变量和静态方法。 诚然，实例对象也可以访问静态变量和方法 UML中静态变量、常量、方法以下划线标注，定义时以修饰符 static 修饰定义即可，常量则再加上 final ，比如： final static double PI = 3.1415 可见性修饰符补充：package (default) public private protected 修饰符及可见性描述： 修饰符 可见性 (default) 可被同一个包中的任一类访问，仅限同一包之中（也称包私有或包内访问） public 能被任意其它类访问 private 限定只能在自身的类中访问 protected 限定只能子类访问 注： ｐrivate 只能应用在类的成员上。修饰符 public 可以应用在类或类的成员上。局部变量上使用修饰符 public、private 会导致编译错误。 数据域封装为了同时保证数据域的封装和数据安全修改，一般通过一个 get 方法进行数据的获取，通过 set 方法进行数据的修改。 其中 get 方法称为访问器（accessor）， set 方法称为称为修改器（mutator）。 1234public returnType getPropertyName(); //get的常规定义public boolean isPropertyName(); //当返回值是boolean类型时的常规定义public void setPropertyName(dataType propertyValue); //set的常规定义 不可变对象不可变对象需要满足以下三条要求 所有数据域（属性）都是私有的 没有 set 方法 没有一个 get 方法方法会返回只想可变数据域的引用 this引用在引用隐藏数据域以及调用一个重载的构造方法时，this引用是必须的 this是指向调用对象本身的引用名，可通过调用 this引用对象的实例成员 注：Java要求 this 放在其它可执行语句之前 类中的关系 关联。 描述两个类之间的活动，uml中采用实线表示 聚合。描述两个对象的归属关系，所有者对象称为聚集对象，其类称为聚集类，从属的则是被聚集对象，被聚集类。（一个对象可被多的聚集对象拥有）。uml中用空心菱形表示 组合。一个对象只归属一个聚集对象，那它和聚集对象间就是组合关系。uml中用实心菱形表示 继承。通过一个定义的通用类（父类、超类、基类），扩充该类为一个更加特定的类（子类、扩展类、派生类）的操作。 继承与组合：继承是 “is-a” 的关系建模，而组合是 “has-a” 的关系建模 基本数据类型与数据包装类Q：为什么要将基本数据类型作为对象处理？ A：Java中某些方法的参数必须是对象 Q：为什么通常情况下基本数据类型不作为对象来处理？ A：处理对象需要额外的系统开销，会降低语言的性能 基本数据类型对象类（也称数据包装类）： Integer Byte Short Float Double Character Boolean 这些对象类所属包：java.lang 装箱（boxing）：将基本类型值转换成包装对象的过程 开箱（unboxing）：将包装对象转换成基本数据值的过程 继承与多态继承语法如下： 12//此处例子为Circle类继承GeometricObject类public class Circle extends GeometricObject 不同于this 对调用对象的引用，super指的是这个关键字所在类的类（与this相同，super也应该写在构造方法的第一条语句处），使用途径： 调用父类的构造方法（子类能继承父类的属性、普通方法，不能继承其构造方法） 调用父类的方法（一般用于方法的重写） 如果子类的构造方法中没有显式调用父类构造方法，编译器就会自动地将super()作为构造方法的第一句，如下： 12345678//下列两者等价public ClassName(){ statements;}public ClassName(){ super(); statements;} 注：静态方法无法被覆盖，如果父类中定义的静态方法在子类中被重新定义，那么在父类中定义的静态方法将被隐藏，可通过SuperClassName.staticMethodName调用隐藏的静态方法。 方法重写与方法重载 方法重写指两方法具有相同的签名（方法名和参数列表）和返回值，发生在继承关系的不同类中 方法重写指两方法具有相同的方法名，但参数列表不同，可发生在继承关系的不同类中，也可以发生在任何一个类之中 通常在方法重写前加上重写标注：@override，以表明接下来的方法为重写方法，要注意的是加上该标注后，后面的方法必须要重写父类的一个方法，如果没有重写方法，则会出现编译错误。 toString方法与equals方法由于所有没有显式继承关系的Java类都继承于java.lang.Object，而该类中有方法toString()，所有所有类都会继承该方法，默认下System.out.print(object)等价于System.out.print(object.toString())，如果要返回特定的信息，就需要改写该方法。 此外，java.lang.object中还有一个方便、常用的方法：equals()，用于测试两个对象是否相等 而==用来比较值是否相等 注：重写equals方式时，应该这样：equals(Object obj)，而不是equals(SomeClassName obj) 多态多态指父类的变量可以指向子类对象 一些解释：每个子类实例既是自身的实例，也是其父类的实例，而其父类的实例不能是子类的实例。即使用父类对象的地方都可以使用子类对象。 动态绑定描述：方法在沿着继承链的多个类中实现，JVM在运行时决定调用那个方法 具体调用哪个方法取决于 对象的实际类型，而非声明类型 如果实际类型中实现该方法，则沿着继承链依次向前，找到的第一个就是JVM将调用的方法 类型转换要点：隐式转换(implicit casting)显式转换(explicit casting) Q：为什么需要类型转换？ A：因为虽然声明类型不等于实际类型，但是声明类型决定了JVM在编译时具体匹配的方法 一个子类的实例总可以转换成一个父类的实例，该操作称为向上转换（upcasting），为确保转换的正确性，可在转换前加上一个判断操作：isinstanceof（注：isinstance并不是一个方法，而是一个运算符，用于两个对象，使用举例如下代码块） 1Circle isinstanceof GeometricObject; //其结果为boolean型 注：由于.操作符优先级高于类型转换，所有需要将类型转换与对象名用括号括起来，使之先于.操作 注：对于对象引用和基本类型值而言，类型转换的操作有所不同，对基本类型值进行类型转换会返回一个新的值，而对对象引用进行类型转换并不会创建新的对象，而是指向同一个对象。 关于声明类型与动态绑定的一个说明对了一个继承关系：Parent类和Child类， 声明Parent p = new Child()，那么p的声明类型为Parent，实际类型为Child，由于声明类型的缘故，p不能调用出现在Child而不出现在Parent的方法；而对于两者都有的方法（同一签名的方法），由于动态绑定的缘故，p会调用Child类中的该方法。 如何防止拓展和重写要点：利用final修饰 被final修饰的类和方法是无法被拓展的。被final修饰的类称为最终类，无法被继承，常见的最终类有：Math String StringBuilder StringBuffer等。被final修饰的方法称为最终方法。 常用类BigInteger和BigDecimal类作用：表示任意大小和精度的整数或者浮点数 方法： add subtract multiple divide remainder compareTo 所属包：java.math 12345678910//创建及使用BigInteger element = new BigInteger(String); //注：只接受String类参数BigDecimal element = new BigDecimal(String);//使用举例BigInteger a = new BigInterger(\"293726028508236\");BigInteger b = new BigInterger(\"3253259723\");BigInteger c = a.multiply(b);BigDecimal d = a.divide(b, 20, BigDecimal.ROUND_UP); //控制精度，此处为保留小数点后20位，舍入方式为BigDecimal.ROUND_UP的BIgDecimal对象 String类特点： 不可更改。一旦创建，其内容无法改变 限定字符串对象：为提高系统效率节约内存，对于相同字符序列的字符串，Java虚拟机使用同一个实例 123String s1 = \"hello world\";String s2 = \"hello world\";System.out.print(s1 == s2); //输出为true,即两个\"hello world\"在系统中为同一个字符串对象，也称限定字符串对象 字符串与数组间的转换： 1234char[] chars = &quot;Java&quot;.toCharArray();String str = new String(new char[]{&apos;J&apos;,&apos;a&apos;,&apos;v&apos;,&apos;a&apos;});String str = String.valueOf(new char[]{&apos;J&apos;,&apos;a&apos;,&apos;v&apos;,&apos;a&apos;}) 将字符和数值转换成字符串： 利用连接符号 + 利用 String 类的静态方法 valueOf 字符串的格式化： 123456String.format(format, item1, item2, ..., itemk);//举例如下String s = String.format(\"%7.2f%6d%-4s\", 45.446, 12, \"AB\");//注：以下两种形式等价：System.out.printf(format, item1, item2, ..., itemk);System.out.print(String.format(format, item1, item2, ..., itemk)); StringBuilder和StringBuffer类要点：此两类类似与String类，区别在于此两类是可变的； 一般而言，任何需要使用字符串的地方，都可以使用这两类，且比String类更加灵活。 两者的使用区别：多任务并发访问情况下，采用StringBuffer，而如果是单任务访问，StringBuilder则更有效果（StringBuffer中修改缓冲区的方法是同步的）。 所有能使用StringBuilder的地方都可以使用StringBuffer。 ArrayList类要点：一种泛型类，可用来存储对象的数组，数组大小可变 泛型类解释：以ArrayList为例，ArrayList为泛型类，具有泛型类型E，创建时，可执行一个具体的类型来代替E 123456//创建ArrayList&lt;java.util.Data&gt; dates = new ArrayList&lt;java.util.Date&gt;();ArrayList&lt;String&gt; cities = new ArrayList&lt;String&gt;();//JDK1.7开始，下列两者等效，此特性称为推导类型ArrayList&lt;AConcreteType&gt; list = new ArrayList&lt;AconcreteType&gt;();ArrayList&lt;AConcreteType&gt; list = new ArrayList(); 比较有用的几个方法： Arrays.aslist()：传入一个数组对象，会返回一个列表，该列表可以传递给ArrayList用于构造ArrayList ArraysList.toArray()：用上面一个作用相反，将ArrayList变为数组对象 java.util.Collections.sort()：用于可元素可比较的列表，可将其对元素进行排序 java.util.Collections.max()：返回列表最大元素 java.util.Collections.min()：返回列表最小元素 java.util.Collections.shuffle()：可随机打乱列表的元素 注：可以通过Object.getClass()放回对象的对象类型信息 其它常用Java类Data类 Random类 Point2D类 Integer与Double类 抽象类和接口抽象类要点：有时候，当一个父类设计得过于抽象，以至于没有任何具体实例时，这种类称为抽象类。 抽象类无法用于创建对象实例；可包括抽象方法，这种方法的具体步骤将在子类中实现 在UML中，抽象类名用斜体字体表示 抽象类的签名中，需要加上abstract关键字 抽象类的构造方法应该是protected的，以确保只能被其继承子类所调用 继承抽象类的子类如果不是抽象类，则必须具体实现抽象父类中的所有抽象方法，如果无法实现抽象父类的所有抽象方法，那么子类就应该是一个抽象类 父类是非抽象类，子类也可以定义为抽象类 满足以下任意条件的类就是抽象类： 显式地包含了一个抽象方法的声明 父类声明的抽象方法为在该类和其父类中实现 父接口中声明或继承一个方法，且类中未声明或继承一个方法来实现它 类中有一个未实现的方法（**自定义或继承） 抽象方法的好处： 抽象类中写抽象方法后，可以以抽象类声明某个子类，然后通过动态绑定来绑定具体的实现方法 接口要点：只包含变量和抽象方法的，与类相似的结构。是公共静态常量和公共抽象实例方法的集合 可看做一种特殊的类，与抽象类相似，无法创建实例。类与接口之间的关系称为 接口继承，也简称为继承。 接口之间的继承可以是多继承，一个类可以实现（关键字implements）多个接口 接口中所有数据字段都隐含为public static final，所有方法都隐含为public abstract 12345678/*修饰符 interface 接口名{ 常量声明 方法签名}*/modifier interface InterfaceName {} 常用几个接口（都包含在包java.lang中）： Comparable Cloneable 为空接口，（空接口称为标记接口） Runnable","link":"/2019/09/27/类和对象/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"随笔","slug":"随笔","link":"/tags/随笔/"}],"categories":[{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"随笔","slug":"随笔","link":"/categories/随笔/"}]}